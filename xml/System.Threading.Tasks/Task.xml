<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6733c9462cb2e559f3548920993b66f1794e9a88" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73380837" /></Metadata><TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="F#" Value="type Task = class&#xA;    interface IAsyncResult&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>非同期操作を表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 <xref:System.Threading.Tasks.Task> クラスは、値を返さず、通常は非同期的に実行する1つの操作を表します。 <xref:System.Threading.Tasks.Task> オブジェクトは、.NET Framework 4 で最初に導入された[タスクベースの非同期パターン](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)の中心的なコンポーネントの1つです。 <xref:System.Threading.Tasks.Task> オブジェクトによって実行される作業は通常、メインアプリケーションスレッド上で同期的に実行されるのではなく、スレッドプールのスレッドで非同期的に実行されるため、<xref:System.Threading.Tasks.Task.Status%2A> プロパティ、<xref:System.Threading.Tasks.Task.IsCanceled%2A>、<xref:System.Threading.Tasks.Task.IsCompleted%2A>、および <xref:System.Threading.Tasks.Task.IsFaulted%2A> の各プロパティを使用できます。。タスクの状態を確認します。 通常、ラムダ式を使用して、タスクが実行する作業を指定します。  
  
 値を返す操作の場合は、<xref:System.Threading.Tasks.Task%601> クラスを使用します。  
  
 このセクションの内容:  
  
 [タスクのインスタンス化の例](#Instant)   
 [タスク  の作成と実行](#Creating)  
 [タスクの作成と実行  の分離](#Separating)  
 [1 つ以上のタスクが完了するのを待機して](#WaitingForOne)い   
 [タスクとカルチャの](#Culture)   
 [デバッガー開発者向け](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a>タスクのインスタンス化  
 次の例では、4つのタスクを作成して実行します。 3つのタスクは、型 <xref:System.Object>の引数を受け取る `action`という名前の <xref:System.Action%601> デリゲートを実行します。 4番目のタスクは、タスク作成メソッドの呼び出しでインラインで定義されているラムダ式 (<xref:System.Action> デリゲート) を実行します。 各タスクはインスタンス化され、別の方法で実行されます。  
  
-   タスク `t1` はタスククラスコンストラクターを呼び出すことによってインスタンス化されますが、タスク `t2` が開始された後にのみ、<xref:System.Threading.Tasks.Task.Start> メソッドを呼び出すことによって開始されます。  
  
-   タスク `t2` は、<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> メソッドを呼び出すことによって、1回のメソッド呼び出しでインスタンス化され、開始されます。  
  
-   タスク `t3` は、<xref:System.Threading.Tasks.Task.Run%28System.Action%29> メソッドを呼び出すことによって、1回のメソッド呼び出しでインスタンス化され、開始されます。  
  
-   タスク `t4` は、<xref:System.Threading.Tasks.Task.RunSynchronously> メソッドを呼び出すことによって、メインスレッドで同期的に実行されます。  
  
 タスク `t4` は同期的に実行されるため、メインアプリケーションスレッドで実行されます。 残りのタスクは、通常、1つ以上のスレッドプールのスレッドで非同期的に実行されます。  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a>タスクの作成と実行  
 <xref:System.Threading.Tasks.Task> インスタンスは、さまざまな方法で作成できます。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]から使用できる最も一般的な方法は、静的な <xref:System.Threading.Tasks.Task.Run%2A> メソッドを呼び出すことです。 <xref:System.Threading.Tasks.Task.Run%2A> メソッドは、既定値を使用してタスクを開始する簡単な方法を提供し、追加のパラメーターを必要としません。 次の例では、<xref:System.Threading.Tasks.Task.Run%28System.Action%29> のメソッドを使用して、ループするタスクを開始し、ループの反復回数を表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 代替手段として、[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]でタスクを開始する最も一般的な方法は、静的な <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> メソッドです。 <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> プロパティは、<xref:System.Threading.Tasks.TaskFactory> オブジェクトを返します。 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> メソッドのオーバーロードを使用すると、タスクの作成オプションとタスクスケジューラに渡すパラメーターを指定できます。 次の例では、<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> メソッドを使用してタスクを開始します。 これは、前の例のコードと機能的には同等です。  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 詳細な例については、「[タスクベースの非同期プログラミング](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)」を参照してください。  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a>タスクの作成と実行の分離  
 <xref:System.Threading.Tasks.Task> クラスには、タスクを初期化するが、実行のスケジュールが設定されていないコンストラクターも用意されています。 パフォーマンス上の理由により、<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> または <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> のいずれかの方法を使用して計算タスクを作成およびスケジュール設定することをお勧めしますが、作成とスケジュールを分離する必要があるシナリオでは、コンストラクターを使用してから <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> メソッドを呼び出すことができます。タスクを後で実行するようにスケジュールを設定します。  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a>1つ以上のタスクが完了するのを待機しています  
 タスクは通常、スレッドプールのスレッドで非同期に実行されるため、タスクを作成して開始するスレッドは、タスクがインスタンス化されるとすぐに実行を継続します。 場合によっては、呼び出し元のスレッドがメインアプリケーションスレッドである場合、タスクが実際に実行を開始する前にアプリが終了することがあります。 それ以外の場合、アプリケーションのロジックでは、1つ以上のタスクが実行を完了したときにのみ、呼び出し元のスレッドが実行を継続することが必要になる場合があります。 1つ以上のタスクが完了するのを待機するために `Wait` メソッドを呼び出すことによって、呼び出し元スレッドと起動する非同期タスクの実行を同期できます。  
  
 1つのタスクが完了するまで待機するには、<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> メソッドを呼び出すことができます。 <xref:System.Threading.Tasks.Task.Wait%2A> メソッドを呼び出すと、単一クラスのインスタンスの実行が完了するまで、呼び出し元のスレッドがブロックされます。  
  
 次の例では、パラメーターなしの <xref:System.Threading.Tasks.Task.Wait> メソッドを呼び出して、タスクが完了するまで無条件に待機します。 このタスクは、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> メソッドを呼び出して2秒間スリープ状態にすることで、作業をシミュレートします。  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 タスクの完了を条件付きで待機することもできます。 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> および <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> メソッドは、タスクが終了するまで、またはタイムアウト間隔が経過するまで、呼び出し元のスレッドをブロックします。 次の例では、2秒間スリープするタスクを起動しますが、1秒間のタイムアウト値を定義するため、呼び出し元のスレッドはタイムアウトが経過するまでブロックされ、タスクの実行が完了するまでブロックされます。  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> および <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> メソッドを呼び出すことによって、キャンセルトークンを指定することもできます。 <xref:System.Threading.Tasks.Task.Wait%2A> メソッドの実行中にトークンの <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> プロパティが `true` または `true` になると、メソッドは <xref:System.OperationCanceledException>をスローします。  
  
 場合によっては、一連の実行中の一連のタスクが完了するまで待機する必要がありますが、それがどのようなタスクであるかは気にしません。  このためには、<xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> メソッドのオーバーロードの1つを呼び出すことができます。  次の例では、3つのタスクを作成します。各タスクは、ランダムな数値ジェネレーターによって決定された間隔でスリープします。 <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> メソッドは、最初のタスクが完了するまで待機します。 この例では、3つのタスクすべての状態に関する情報が表示されます。  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 <xref:System.Threading.Tasks.Task.WaitAll%2A> メソッドを呼び出すことによって、一連のタスクが完了するまで待機することもできます。 次の例では、10個のタスクを作成し、すべての10が完了するまで待機して、その状態を表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 1つ以上のタスクが完了するまで待機すると、次の例に示すように、実行中のタスクでスローされた例外は、`Wait` メソッドを呼び出すスレッドに反映されることに注意してください。 12個のタスクが起動され、そのうち3つは正常に完了し、そのうち3つは例外をスローします。 残りの6つのタスクのうち、3つは開始前にキャンセルされ、3つは実行中にキャンセルされます。 <xref:System.Threading.Tasks.Task.WaitAll%2A> メソッドの呼び出しで例外がスローされ、`try`/`catch` ブロックによって処理されます。  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 タスクベースの非同期操作での例外処理の詳細については、「[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a>タスクとカルチャ  
 [!INCLUDE[net_v46](~/includes/net-v46-md.md)]を対象とするデスクトップアプリ以降では、タスクを作成して呼び出すスレッドのカルチャがスレッドのコンテキストの一部になります。 つまり、タスクが実行されるスレッドの現在のカルチャに関係なく、タスクの現在のカルチャが呼び出し元スレッドのカルチャになります。 [!INCLUDE[net_v46](~/includes/net-v46-md.md)]前に .NET Framework のバージョンを対象とするアプリの場合、タスクのカルチャは、タスクが実行されるスレッドのカルチャになります。 詳細については、「<xref:System.Globalization.CultureInfo>」トピックの「カルチャとタスクベースの非同期操作」セクションを参照してください。  
  
> [!NOTE]
>  ストアアプリは、設定の Windows ランタイムに従い、既定のカルチャを取得します。  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a>デバッガー開発者向け  
 カスタムデバッガーを実装する開発者にとっては、タスクのいくつかの内部メンバーとプライベートメンバーが役に立つ場合があります (これらはリリースごとに変更される可能性があります)。 `m_taskId` フィールドは、<xref:System.Threading.Tasks.Task.Id%2A> プロパティのバッキングストアとして機能しますが、デバッガーから直接このフィールドにアクセスする方が、プロパティの getter メソッドを使用して同じ値にアクセスするよりも効率的な場合があります (`s_taskIdCounter` カウンターを使用して、タスクで使用可能な次の ID。 同様に、`m_stateFlags` フィールドには、タスクの現在のライフサイクルステージに関する情報が格納されます。情報には、<xref:System.Threading.Tasks.Task.Status%2A> プロパティを通じてアクセスすることもできます。 `m_action` フィールドにはタスクのデリゲートへの参照が格納され、`m_stateObject` フィールドには、開発者によってタスクに渡される非同期状態が格納されます。 最後に、スタックフレームを解析するデバッガーの場合、`InternalWait` メソッドは、タスクが待機操作に入ったときのマーカーとして機能します。   
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="M:System.Threading.Tasks.Task.Dispose" />を除く <see cref="T:System.Threading.Tasks.Task" />のすべてのメンバーはスレッドセーフであり、複数のスレッドから同時に使用することができます。</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">.NET Framework を使用した並列プログラミングのサンプル</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <summary>指定したアクションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターは、タスクの作成と開始を分離する必要がある高度なシナリオでのみ使用してください。  
  
 このコンストラクターを呼び出すのではなく、静的 <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> または <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> メソッドを呼び出すことによって、<xref:System.Threading.Tasks.Task> オブジェクトをインスタンス化し、タスクを起動するのが最も一般的な方法です。  
  
 API のコンシューマーが待機する必要のあるタスクを実行するためだけにアクションのないタスクが必要な場合は、<xref:System.Threading.Tasks.TaskCompletionSource%601> を使用する必要があります。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> コンストラクターを使用して、指定したディレクトリ内のファイル名を取得するタスクを作成します。 すべてのタスクは、ファイル名を1つの <xref:System.Collections.Concurrent.ConcurrentBag%601> オブジェクトに書き込みます。 この例では、<xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> メソッドを呼び出してすべてのタスクが完了したことを確認し、<xref:System.Collections.Concurrent.ConcurrentBag%601> オブジェクトに書き込まれたファイル名の総数を表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 次の例は、<xref:System.Threading.Tasks.Task.Run%28System.Action%29> メソッドを使用して1回の操作でタスクをインスタンス化して実行する点を除いて同じです。 メソッドは、タスクを表す <xref:System.Threading.Tasks.Task> オブジェクトを返します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="cancellationToken">新しいタスクが観察する <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>指定したアクションおよび <see cref="T:System.Threading.Tasks.Task" /> で新しい <see cref="T:System.Threading.CancellationToken" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを呼び出すのではなく、静的 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> メソッドと <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> メソッドを呼び出すことによって、<xref:System.Threading.Tasks.Task> オブジェクトをインスタンス化し、タスクを起動するのが最も一般的な方法です。 このコンストラクターによって提供される唯一の利点は、オブジェクトのインスタンス化をタスクの呼び出しから分離できることです。  
  
 詳細については、「[タスクの並列化 (タスク並列ライブラリ)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) 」および「[マネージスレッドでのキャンセル](~/docs/standard/threading/cancellation-in-managed-threads.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> コンストラクターを呼び出して、C:\Windows\System32 ディレクトリ内のファイルを反復処理するタスクを作成します。 ラムダ式は、<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドを呼び出して、各ファイルに関する情報を <xref:System.Collections.Generic.List%601> オブジェクトに追加します。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> ループによって呼び出された、デタッチされた入れ子になった各タスクは、キャンセルトークンの状態をチェックし、キャンセルが要求された場合は <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> メソッドを呼び出します。 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> メソッドは、呼び出し元のスレッドが <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> メソッドを呼び出すと `catch` ブロックで処理される <xref:System.OperationCanceledException> 例外をスローします。  その後、<xref:System.Threading.Tasks.Task.Start%2A> メソッドが呼び出され、タスクが開始されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定したアクションと作成オプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを呼び出すのではなく、静的な <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> メソッドを呼び出すことによって、<xref:System.Threading.Tasks.Task> オブジェクトをインスタンス化し、タスクを起動するための最も一般的な方法です。 このコンストラクターによって提供される唯一の利点は、オブジェクトのインスタンス化をタスクの呼び出しから分離できることです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskCreationOptions" /> の無効な値を指定しています。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="state">アクションによって使用されるデータを表すオブジェクト。</param>
        <summary>指定したアクションと状態で新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを呼び出すのではなく、静的な <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> メソッドを呼び出すことによって、<xref:System.Threading.Tasks.Task> オブジェクトをインスタンス化し、タスクを起動するための最も一般的な方法です。 このコンストラクターによって提供される唯一の利点は、オブジェクトのインスタンス化をタスクの呼び出しから分離できることです。  
  
   
  
## Examples  
 次の例では、6文字の単語の配列を定義しています。 各単語は引数として <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> コンストラクターに渡され、<xref:System.Action%601> デリゲートによって単語内の文字がスクランブルされます。その後、元の単語とそのスクランブルバージョンが表示されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が null です。</exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="cancellationToken">新しいタスクが観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定したアクションと作成オプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを呼び出すのではなく、静的な <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> メソッドを呼び出すことによって、<xref:System.Threading.Tasks.Task> オブジェクトをインスタンス化し、タスクを起動するための最も一般的な方法です。 このコンストラクターによって提供される唯一の利点は、オブジェクトのインスタンス化をタスクの呼び出しから分離できることです。  
  
 詳細については、「[タスクの並列化 (タスク並列ライブラリ)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) 」および「[タスクのキャンセル](~/docs/standard/parallel-programming/task-cancellation.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="cancellationToken" /> を作成した <see cref="T:System.Threading.CancellationTokenSource" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskCreationOptions" /> の無効な値を指定しています。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="state">アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しいタスクが観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>指定したアクション、状態、およびオプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを呼び出すのではなく、静的な <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> メソッドを呼び出すことによって、<xref:System.Threading.Tasks.Task> オブジェクトをインスタンス化し、タスクを起動するための最も一般的な方法です。 このコンストラクターによって提供される唯一の利点は、オブジェクトのインスタンス化をタスクの呼び出しから分離できることです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="cancellationToken" /> を作成した <see cref="T:System.Threading.CancellationTokenSource" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="state">アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定したアクション、状態、およびオプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを呼び出すのではなく、静的な <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> メソッドを呼び出すことによって、<xref:System.Threading.Tasks.Task> オブジェクトをインスタンス化し、タスクを起動するための最も一般的な方法です。 このコンストラクターによって提供される唯一の利点は、オブジェクトのインスタンス化をタスクの呼び出しから分離できることです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskCreationOptions" /> の無効な値を指定しています。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="state">アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しいタスクが観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定したアクション、状態、およびオプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターを呼び出すのではなく、静的な <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> メソッドを呼び出すことによって、<xref:System.Threading.Tasks.Task> オブジェクトをインスタンス化し、タスクを起動するための最も一般的な方法です。 このコンストラクターによって提供される唯一の利点は、オブジェクトのインスタンス化をタスクの呼び出しから分離できることです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="cancellationToken" /> を作成した <see cref="T:System.Threading.CancellationTokenSource" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskCreationOptions" /> の無効な値を指定しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.Task" /> が作成されたときに渡される状態オブジェクトを取得します。渡されなかった場合は null。</summary>
        <value>タスクの作成時にそのタスクに渡された状態データを表す <see cref="T:System.Object" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オブジェクトを元の型にキャストして、データを取得します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedTask : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既に正常に完了したタスクを取得します。</summary>
        <value>正常に完了したタスク。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、<xref:System.Threading.Tasks.Task.Status%2A> プロパティが <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> に設定されているタスクを返します。 値を返して完了まで実行するタスクを作成するには、<xref:System.Threading.Tasks.Task.FromResult%2A> メソッドを呼び出します。  
  
 このプロパティ値を繰り返し取得しようとすると、必ずしも同じインスタンスが返されるとは限りません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="member this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">継続をキャプチャされた元のコンテキストにマーシャリングする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>この <see cref="T:System.Threading.Tasks.Task" /> を待機するために使用する awaiter を構成します。</summary>
        <returns>このタスクを待機するために使用するオブジェクト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期に実行する継続タスクを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期に実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task> は、現在のタスクが完了するまで実行されるようにスケジュールされません。実行が正常に完了したか、処理不能な例外が原因でエラーが発生したか、または取り消されたために早期に終了したことが原因です。  
  
   
  
## Examples  
 次の例では、100のランダムな日付と時刻の値を配列に設定するタスクを定義します。 配列が完全に設定されたら、<xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> メソッドを使用して、最も古い日付値と最新の日付値を選択します。  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 継続タスクが実行される前にコンソールアプリケーションが終了する可能性があるため、この例が終了する前に継続が実行を完了するように、<xref:System.Threading.Tasks.Task.Wait> メソッドが呼び出されます。  
  
 その他の例については、「[継続タスクを使用](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)したタスクの連結」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">タスクの完了時に実行するアクション。 実行時に、完了したタスクと、呼び出し元が提供した状態オブジェクトが、引数としてデリゲートに渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <summary>呼び出し元が提供した状態情報を受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに実行される継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task> は、現在のタスクが完了するまで実行されるようにスケジュールされません。実行が正常に完了したか、ハンドルされない例外が原因でエラーが発生したか、またはキャンセルによって早期に終了したために完了します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>キャンセル トークンを受け取って、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期的に実行される継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task> は、現在のタスクが完了するまで実行されるようにスケジュールされません。実行が正常に完了したか、処理不能な例外が原因でエラーが発生したか、または取り消されたために早期に終了したことが原因です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">トークンを作成した <see cref="T:System.Threading.CancellationTokenSource" /> は、既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">指定した <paramref name="continuationOptions" /> に従って実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>対象のタスクが完了したときに、指定した <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> に従って実行される継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task> は、現在のタスクが完了するまで実行されるようにスケジュールされません。 `continuationOptions` パラメーターによって指定された継続条件が満たされない場合、継続タスクはスケジュールではなくキャンセルされます。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Tasks.TaskContinuationOptions> を使用して、継続元タスクが完了したときに継続タスクを同期的に実行するように指定しています。 (指定したタスクが既に完了している場合 <xref:System.Threading.Tasks.Task.ContinueWith%2A> が呼び出されると、同期継続は <xref:System.Threading.Tasks.Task.ContinueWith%2A> を呼び出しているスレッドで実行されます)。  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期に実行する継続タスクを作成します。 継続タスクは、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task> は、現在のタスクが完了するまで実行されるようにスケジュールされません。実行が正常に完了したか、処理不能な例外が原因でエラーが発生したか、または取り消されたために早期に終了したことが原因です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が <see langword="null" /> です。  
  
- または - 
<paramref name="scheduler" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>呼び出し元が提供した状態情報およびキャンセル トークンを受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> の完了時に非同期的に実行される継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task> は、現在のタスクが完了するまで実行されるようにスケジュールされません。実行が正常に完了したか、処理不能な例外が原因でエラーが発生したか、または取り消されたために早期に終了したことが原因です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行時に、完了したタスクおよび呼び出し元が提供した状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>呼び出し元が提供した状態情報を受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに実行される継続タスクを作成します。 継続タスクは、指定した一連の条件に基づいて実行されます。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task> は、現在のタスクが完了するまで実行されるようにスケジュールされません。 `continuationOptions` パラメーターによって指定された継続条件が満たされない場合、継続タスクはスケジュールではなくキャンセルされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。  実行時に、完了したタスクおよび呼び出し元が提供した状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>呼び出し元が提供した状態情報を受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期的に実行される継続タスクを作成します。 継続タスクは、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task> は、現在のタスクが完了するまで実行されるようにスケジュールされません。実行が正常に完了したか、処理不能な例外が原因でエラーが発生したか、または取り消されたために早期に終了したことが原因です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">指定した <paramref name="continuationOptions" /> に従って実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>対象のタスクが完了したときに、指定した <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> に従って実行される継続タスクを作成します。 この継続タスクは、キャンセル トークンを受け取り、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task> は、現在のタスクが完了するまで実行されるようにスケジュールされません。 `continuationOptions` パラメーターを使用して指定した条件が満たされない場合、継続タスクはスケジュールではなくキャンセルされます。  
  
   
  
## Examples  
 System.threading.tasks.task.continuewith を使用して、バックグラウンドとユーザーインターフェイススレッドの両方で作業を実行する例を次に示します。  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">トークンを作成した <see cref="T:System.Threading.CancellationTokenSource" /> は、既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> 引数が null です。  
  
- または - 
<paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行時に、完了したタスクおよび呼び出し元が提供した状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>呼び出し元が提供した状態情報およびキャンセル トークンを受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行される継続タスクを作成します。 継続タスクは、指定した一連の条件に基づいて実行され、指定したスケジューラが使用されます。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task> は、現在のタスクが完了するまで実行されるようにスケジュールされません。 `continuationOptions` パラメーターを使用して指定した条件が満たされない場合、継続タスクはスケジュールではなくキャンセルされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction"><see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task`1" /> が完了して値を返したときに非同期的に実行される継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task%601> は、現在のタスクが完了するまで実行されるようにスケジュールされません。実行が正常に完了したか、処理不能な例外が原因でエラーが発生したか、または取り消されたために早期に終了したことが原因です。  
  
   
  
## Examples  
 次の例は、System.threading.tasks.task.continuewith メソッドの使用方法を示しています。  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <summary>呼び出し元から提供される状態情報を受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期的に実行され、値を返す継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task%601> は、現在のタスクが完了するまで実行されるようにスケジュールされません。実行が正常に完了したか、処理不能な例外が原因でエラーが発生したか、または取り消されたために早期に終了したことが原因です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了して値を返したときに非同期的に実行される継続タスクを作成します。 この継続タスクは、キャンセル トークンを受け取ります。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task%601> は、現在のタスクが完了するまで実行されるようにスケジュールされません。実行が正常に完了したか、処理不能な例外が原因でエラーが発生したか、または取り消されたために早期に終了したことが原因です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。  
  
- または - 
トークンを作成した <see cref="T:System.Threading.CancellationTokenSource" /> は、既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction"><paramref name="continuationOptions" /> で指定した条件に従って実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>指定された継続のオプションに従って実行され、値を返す継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task%601> は、現在のタスクが完了するまで実行されるようにスケジュールされません。 `continuationOptions` パラメーターによって指定された継続条件が満たされない場合、継続タスクはスケジュールではなくキャンセルされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了して値を返したときに非同期的に実行される継続タスクを作成します。 継続タスクは、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task%601> は、現在のタスクが完了するまで実行されるようにスケジュールされません。実行が正常に完了したか、処理不能な例外が原因でエラーが発生したか、または取り消されたために早期に終了したことが原因です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が null です。  
  
- または - 
<paramref name="scheduler" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行時に、完了したタスクおよび呼び出し元が提供した状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了して値を返したときに非同期的に実行される継続タスクを作成します。 この継続タスクは、呼び出し元が提供した状態情報とキャンセル トークンを受け取ります。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task%601> は、現在のタスクが完了するまで実行されるようにスケジュールされません。実行が正常に完了したか、処理不能な例外が原因でエラーが発生したか、または取り消されたために早期に終了したことが原因です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行時に、完了したタスクおよび呼び出し元が提供した状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに、指定したタスク継続オプションに基づいて実行される継続タスクを作成します。 この継続タスクは、呼び出し元が提供した状態情報を受け取ります。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task%601> は、現在のタスクが完了するまで実行されるようにスケジュールされません。 `continuationOptions` パラメーターによって指定された継続条件が満たされない場合、継続タスクはスケジュールではなくキャンセルされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。  実行時に、完了したタスクおよび呼び出し元が提供した状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期に実行する継続タスクを作成します。 この継続タスクは、呼び出し元が提供した状態情報を受け取り、指定したスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task%601> は、現在のタスクが完了するまで実行されるようにスケジュールされません。実行が正常に完了したか、処理不能な例外が原因でエラーが発生したか、または取り消されたために早期に終了したことが原因です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">指定した <c>continuationOptions</c> に従って実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>指定された継続のオプションに従って実行され、値を返す継続タスクを作成します。 継続タスクは、キャンセル トークンを渡され、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task%601> は、現在のタスクが完了するまで実行されるようにスケジュールされません。 `continuationOptions` パラメーターを使用して指定した条件が満たされない場合、継続タスクはスケジュールではなくキャンセルされます。  
  
   
  
## Examples  
 次の例は、System.threading.tasks.task.continuewith メソッドを継続オプションと共に使用する方法を示しています。  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。  
  
- または - 
トークンを作成した <see cref="T:System.Threading.CancellationTokenSource" /> は、既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> 引数が null です。  
  
- または - 
<paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction"><see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行時に、完了したタスクおよび呼び出し元が提供した状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに、指定したタスク継続オプションに基づいて実行され、値を返す継続タスクを作成します。 この継続タスクは、呼び出し元が提供した状態情報とキャンセル トークンを受け取り、指定したスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された <xref:System.Threading.Tasks.Task%601> は、現在のタスクが完了するまで実行されるようにスケジュールされません。 `continuationOptions` パラメーターを使用して指定した条件が満たされない場合、継続タスクはスケジュールではなくキャンセルされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このタスクの作成に使用される <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> を取得します。</summary>
        <value>このタスクの作成に使用される <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentId : Nullable&lt;int&gt;" Usage="System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行中の <see cref="T:System.Threading.Tasks.Task" /> の ID を返します。</summary>
        <value>システムによって現在実行中のタスクに割り当てられた整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.CurrentId%2A> は、タスクが実行されているコードから現在実行中のタスクの識別子を取得するために使用される、`static` (`Shared` Visual Basic) プロパティです。 これは、特定の <xref:System.Threading.Tasks.Task> インスタンスの識別子を返す <xref:System.Threading.Tasks.Task.Id%2A> プロパティとは異なります。 タスクが実行されているコードの外部から <xref:System.Threading.Tasks.Task.CurrentId%2A> 値を取得しようとすると、プロパティは `null`を返します。  
  
 競合は非常にまれですが、タスク識別子は一意であるとは限りません。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>遅延後に完了するタスクを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="static member Delay : int -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">戻されたタスクを完了するまでに待機するミリ秒数。無期限に待機する場合は -1。</param>
        <summary>指定したミリ秒後に完了するタスクを作成します。</summary>
        <returns>遅延を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Delay%2A> メソッドは、通常、指定された時間間隔でタスクの全体または一部の操作を遅延するために使用されます。 通常、遅延時間は次のようになります。  
  
-   次の例に示すように、タスクの先頭にあります。  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   タスクの実行中に発生します。 この場合、次の例に示すように、<xref:System.Threading.Tasks.Task.Delay%2A> メソッドの呼び出しは、タスク内の子タスクとして実行されます。 <xref:System.Threading.Tasks.Task.Delay%2A> メソッドを呼び出すタスクは非同期的に実行されるため、親タスクは `await` キーワードを使用して完了するまで待機する必要があることに注意してください。  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 指定された遅延時間が経過すると、タスクは <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 状態で完了します。  
  
 この方法は、システムクロックによって異なります。 これは、`millisecondsDelay` 引数がシステムクロックの解像度 (Windows システムで約15ミリ秒) よりも少ない場合に、時間の遅延がシステムクロックの解像度とほぼ同じであることを意味します。  
  
   
  
## Examples  
 次の例は、<xref:System.Threading.Tasks.Task.Delay%2A> メソッドを簡単に使用する方法を示しています。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsDelay" /> 引数は -1 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delay">戻されたタスクを完了するまでに待機する時間。無期限に待機する場合は <see langword="TimeSpan.FromMilliseconds(-1)" />。</param>
        <summary>指定した期間の後に完了するタスクを作成します。</summary>
        <returns>遅延を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された遅延時間が経過すると、タスクは <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 状態で完了します。  
  
 使用シナリオとその他の例については、<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> のオーバーロードに関するドキュメントを参照してください。  
  
 この方法は、システムクロックによって異なります。 これは、`delay` 引数がシステムクロックの解像度 (Windows システムで約15ミリ秒) よりも少ない場合に、時間の遅延がシステムクロックの解像度とほぼ同じであることを意味します。  
  
   
  
## Examples  
 次の例は、<xref:System.Threading.Tasks.Task.Delay%2A> メソッドを簡単に使用する方法を示しています。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="delay" /> は、<see langword="TimeSpan.FromMilliseconds(-1)" /> 以外の負の時間間隔を表します。  
  
- または - 
<paramref name="delay" /> 引数の <see cref="P:System.TimeSpan.TotalMilliseconds" />プロパティが <see cref="F:System.Int32.MaxValue" /> より大きい値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (millisecondsDelay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">戻されたタスクを完了するまでに待機するミリ秒数。無期限に待機する場合は -1。</param>
        <param name="cancellationToken">タスクの完了の待機中に観察するキャンセル トークン。</param>
        <summary>指定したミリ秒後に完了するキャンセル可能なタスクを作成します。</summary>
        <returns>遅延を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定した時間が経過する前にキャンセルトークンがシグナル状態になると、<xref:System.Threading.Tasks.TaskCanceledException> 例外が発生し、タスクが <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態で完了します。  それ以外の場合は、指定された遅延時間が経過すると、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion> の状態でタスクが完了します。  
  
 使用シナリオとその他の例については、<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> のオーバーロードに関するドキュメントを参照してください。  
  
 この方法は、システムクロックによって異なります。 これは、`millisecondsDelay` 引数がシステムクロックの解像度 (Windows システムで約15ミリ秒) よりも少ない場合に、時間の遅延がシステムクロックの解像度とほぼ同じであることを意味します。  
  
   
  
## Examples  
 次の例では、1秒の遅延で <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> メソッドの呼び出しを含むタスクを起動します。 遅延間隔が経過する前に、トークンは取り消されます。 この例の出力は、結果として <xref:System.Threading.Tasks.TaskCanceledException> がスローされ、タスク ' <xref:System.Threading.Tasks.Task.Status%2A> ' プロパティが <xref:System.Threading.Tasks.TaskStatus.Canceled> に設定されていることを示しています。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsDelay" /> 引数は -1 未満です。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <paramref name="cancellationToken" /> は既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (delay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delay">戻されたタスクを完了するまでに待機する時間。無期限に待機する場合は <see langword="TimeSpan.FromMilliseconds(-1)" />。</param>
        <param name="cancellationToken">タスクの完了の待機中に観察するキャンセル トークン。</param>
        <summary>指定した期間の後に完了するキャンセル可能タスクを作成します。</summary>
        <returns>遅延を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定した時間が経過する前にキャンセルトークンがシグナル状態になると、<xref:System.Threading.Tasks.TaskCanceledException> 例外が発生し、タスクが <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態で完了します。  それ以外の場合は、指定された遅延時間が経過すると、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion> の状態でタスクが完了します。  
  
 使用シナリオとその他の例については、<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> のオーバーロードに関するドキュメントを参照してください。  
  
 この方法は、システムクロックによって異なります。 これは、`delay` 引数がシステムクロックの解像度 (Windows システムで約15ミリ秒) よりも少ない場合に、時間の遅延がシステムクロックの解像度とほぼ同じであることを意味します。  
  
   
  
## Examples  
 次の例では、1.5 秒の遅延がある <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> メソッドの呼び出しを含むタスクを起動します。 遅延間隔が経過する前に、トークンは取り消されます。 この例の出力は、結果として <xref:System.Threading.Tasks.TaskCanceledException> がスローされ、タスク ' <xref:System.Threading.Tasks.Task.Status%2A> ' プロパティが <xref:System.Threading.Tasks.TaskStatus.Canceled> に設定されていることを示しています。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 この例には潜在的な競合状態が含まれていることに注意してください。これは、トークンが取り消されたときに、タスクが非同期的に遅延を実行することに依存します。 <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> メソッドを呼び出すと1.5 秒の遅延が発生する可能性がありますが、トークンが取り消される前に <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> メソッドの呼び出しが戻る可能性があります。 その場合、この例では次の出力が生成されます。  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="delay" /> は、<see langword="TimeSpan.FromMilliseconds(-1)" /> 以外の負の時間間隔を表します。  
  
- または - 
<paramref name="delay" /> 引数の <see cref="P:System.TimeSpan.TotalMilliseconds" />プロパティが <see cref="F:System.Int32.MaxValue" /> より大きい値です。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <paramref name="cancellationToken" /> は既に破棄されています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.Task" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="task.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.Task" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task> クラスは、内部的に <xref:System.IDisposable>も実装するリソースを使用するため、<xref:System.IDisposable> インターフェイスを実装します。 ただし、特に、アプリが [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 以降を対象としている場合は、パフォーマンスやスケーラビリティのテストによって、使用パターンに基づいてアプリのパフォーマンスが向上することが示されていない限り、<xref:System.Threading.Tasks.Task.Dispose%2A> を呼び出す必要はありません。 詳細については、「.NET を使用した並列プログラミング」ブログの「[タスクを破棄する必要がありますか](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">タスクが最終的な状態、<see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />、<see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />、または <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> のいずれでもありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="task.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="disposing"><see cref="M:System.Threading.Tasks.Task.Dispose" /> が呼び出されたことが原因でこのメソッドが呼び出されているかどうかを示すブール値。</param>
        <summary><see cref="T:System.Threading.Tasks.Task" /> を破棄し、そのすべてのアンマネージ リソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task> クラスは、内部的に <xref:System.IDisposable>も実装するリソースを使用するため、<xref:System.IDisposable> インターフェイスを実装します。 ただし、特に、アプリが [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 以降を対象としている場合は、パフォーマンスやスケーラビリティのテストによって、使用パターンに基づいてアプリのパフォーマンスが向上することが示されていない限り、<xref:System.Threading.Tasks.Task.Dispose%2A> を呼び出す必要はありません。 詳細については、「.NET を使用した並列プログラミング」ブログの「[タスクを破棄する必要がありますか](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">タスクが最終的な状態、<see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />、<see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />、または <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> のいずれでもありません。</exception>
        <threadsafe><see cref="T:System.Threading.Tasks.Task" /> クラスのほとんどのメンバーとは異なり、このメソッドはスレッドセーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Exception : AggregateException" Usage="System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.AggregateException" /> が途中で終了する原因となった <see cref="T:System.Threading.Tasks.Task" /> を取得します。 <see cref="T:System.Threading.Tasks.Task" /> が正常に完了した場合、または例外がスローされていない場合は、<see langword="null" /> が返されます。</summary>
        <value><see cref="T:System.AggregateException" /> が途中で終了する原因となった <see cref="T:System.Threading.Tasks.Task" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 未処理の例外をスローするタスクは、結果として得られる例外を格納し、<xref:System.Threading.Tasks.Task.Wait%2A> への呼び出しまたは <xref:System.Threading.Tasks.Task.Exception%2A> プロパティへのアクセスで、<xref:System.AggregateException> にラップします。 タスクインスタンスがガベージコレクションされた時間によって監視されない例外は、ファイナライザースレッドで反映されます。 詳細と例については、「[例外処理 (タスク並列ライブラリ)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory" Usage="System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.Task" /> および <see cref="T:System.Threading.Tasks.Task`1" /> インスタンスを作成して構成するためのファクトリ メソッドへのアクセスを提供します。</summary>
        <value>さまざまな <see cref="T:System.Threading.Tasks.Task" /> オブジェクトおよび <see cref="T:System.Threading.Tasks.Task`1" /> オブジェクトを作成可能なファクトリ オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、パラメーターなしの <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> コンストラクターを呼び出すことによって作成されたものと同一の <xref:System.Threading.Tasks.TaskFactory> クラスの既定のインスタンスを返します。 これには、次のプロパティ値があります。  
  
|プロパティ|[値]|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|`null` または <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 このプロパティの最も一般的な用途は、<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> メソッドの1回の呼び出しで新しいタスクを作成して開始することです。  
  
> [!NOTE]
>  [!INCLUDE[net_v45](~/includes/net-v45-md.md)]以降、<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> メソッドは、既定の構成値を使用して <xref:System.Threading.Tasks.Task> オブジェクトを作成する最も簡単な方法を提供します。  
  
 次の例では、静的な <xref:System.Threading.Tasks.Task.Factory%2A> プロパティを使用して、<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> メソッドを2回呼び出します。 最初のは、ユーザーのマイドキュメント ディレクトリ内のファイルの名前を配列に格納し、2番目のは配列にユーザーのマイドキュメント ディレクトリのサブディレクトリの名前を設定します。 次に、<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> メソッドを呼び出します。これにより、最初の2つのタスクの実行が完了した後に、2つの配列内のファイルとディレクトリの数に関する情報が表示されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">タスクを完了させるキャンセル トークン。</param>
        <summary>指定したキャンセル トークンを使ったキャンセルにより完了した <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>キャンセルされたタスク。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="cancellationToken" /> は、キャンセルが要求されていません。<see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> プロパティは <see langword="false" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクによって返される結果の型。</typeparam>
        <param name="cancellationToken">タスクを完了させるキャンセル トークン。</param>
        <summary>指定したキャンセル トークンを使ったキャンセルにより完了した <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>キャンセルされたタスク。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="cancellationToken" /> は、キャンセルが要求されていません。<see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> プロパティは <see langword="false" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromException exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="exception">タスクを完了させる例外。</param>
        <summary>指定した例外で完了した <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>エラーが発生したタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Threading.Tasks.Task.Status%2A> プロパティが <xref:System.Threading.Tasks.TaskStatus.Faulted>、<xref:System.Threading.Tasks.Task.Exception%2A> プロパティに `exception`が格納されている <xref:System.Threading.Tasks.Task> オブジェクトを作成します。 メソッドは、通常、タスクが実行する作業が、長いコードパスを実行する前に例外をスローすることがわかっている場合に使用されます。 例については、「<xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> のオーバーロード」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromException exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクによって返される結果の型。</typeparam>
        <param name="exception">タスクを完了させる例外。</param>
        <summary>指定した例外で完了した <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>エラーが発生したタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Threading.Tasks.Task.Status%2A> プロパティが <xref:System.Threading.Tasks.TaskStatus.Faulted>、<xref:System.Threading.Tasks.Task.Exception%2A> プロパティに `exception`が格納されている <xref:System.Threading.Tasks.Task%601> オブジェクトを作成します。 メソッドは、通常、タスクが実行する作業が、長いコードパスを実行する前に例外をスローすることがわかっている場合に使用されます。 具体的な例を次に示します。  
  
   
  
## Examples  
 次の例は、コマンドライン引数として渡された名前を持つ各ディレクトリ内のファイルのバイト数を計算するコマンドラインユーティリティです。 <xref:System.IO.FileInfo> オブジェクトをインスタンス化し、ディレクトリ内の各ファイルの <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> プロパティの値を取得する長いコードパスを実行するのではなく、この例では、<xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> メソッドを呼び出して、特定のサブディレクトリではエラーが発生したタスクを作成するだけです。まだ.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberSignature Language="F#" Value="static member FromResult : 'Result -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクによって返される結果の型。</typeparam>
        <param name="result">完了したタスクに格納する結果。</param>
        <summary>指定した結果で成功した <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>正常に完了したタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> プロパティが `result`、<xref:System.Threading.Tasks.Task.Status%2A> プロパティが <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>である <xref:System.Threading.Tasks.Task%601> オブジェクトを作成します。 メソッドは、タスクの戻り値が、長いコードパスを実行せずにすぐにわからない場合によく使用されます。 具体的な例を次に示します。  
  
 値を返さないタスクオブジェクトを作成するには、<xref:System.Threading.Tasks.Task.CompletedTask%2A> プロパティからタスクオブジェクトを取得します。  
  
   
  
## Examples  
 次の例は、コマンドライン引数として渡された名前を持つ各ディレクトリ内のファイルのバイト数を計算するコマンドラインユーティリティです。 <xref:System.IO.FileStream> オブジェクトをインスタンス化し、ディレクトリ内の各ファイルの <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> プロパティの値を取得する長いコードパスを実行するのではなく、単に <xref:System.Threading.Tasks.Task.FromResult%2A> メソッドを呼び出して、<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> プロパティがゼロ (0) のタスクを作成します。ディレクトリにファイルがありません。  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberSignature Language="F#" Value="member this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Threading.Tasks.Task" /> を待機するために使用する awaiter を取得します。</summary>
        <returns>awaiter のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アプリケーションコードで使用するためではなく、コンパイラの使用を目的としています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Threading.Tasks.Task" /> インスタンスの ID を取得します。</summary>
        <value>システムによってこの <see cref="T:System.Threading.Tasks.Task" /> インスタンスに割り当てられた識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスク Id は要求に応じて割り当てられ、必ずしもタスクインスタンスの作成順序を表すとは限りません。 競合は非常にまれですが、タスク識別子は一意であるとは限りません。  
  
 タスクが実行されているコード内から現在実行中のタスクのタスク ID を取得するには、<xref:System.Threading.Tasks.Task.CurrentId%2A> プロパティを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCanceled : bool" Usage="System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行が取り消されることによって完了したかどうかを示す値を取得します。</summary>
        <value>タスクが取り消されることによって完了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task> は、次のいずれかの条件下で <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態で完了します。  
  
-   タスクが実行を開始する前に、その <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> がキャンセル用にマークされました。  
  
-   タスクは、同じ <xref:System.Threading.CancellationToken>を持つ <xref:System.OperationCanceledException> をスローすることによって、既にシグナル状態になっている <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> に対して取り消し要求を受信確認しています。  
  
-   タスクは、<xref:System.Threading.CancellationToken> で <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> メソッドを呼び出して、既にシグナル状態になっている <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> の取り消し要求を受信確認しました。  
  
> [!IMPORTANT]
>  <xref:System.Threading.Tasks.Task.IsCanceled%2A> プロパティの値を取得しても、タスクが完了するまで呼び出し元のスレッドはブロックされません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タスクが完了したかどうかを示す値を取得します。</summary>
        <value>タスクが完了した (つまり、<see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />、<see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />、<see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />) のいずれかの最終状態であることを <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> プロパティの値を取得しても、タスクが完了するまで呼び出し元のスレッドはブロックされません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompletedSuccessfully : bool" Usage="System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タスクが完了まで実行されたかどうかを示す値を取得します。</summary>
        <value>タスクが完了まで実行されたかどうかを <see langword="true" /> します。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFaulted : bool" Usage="System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>処理されない例外が発生したことが原因で <see cref="T:System.Threading.Tasks.Task" /> が完了したかどうかを示す値を取得します。</summary>
        <value>タスクがハンドルされない例外をスローした場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.IsFaulted%2A> が `true`の場合、タスクの <xref:System.Threading.Tasks.Task.Status%2A> は <xref:System.Threading.Tasks.TaskStatus.Faulted>と等しく、その <xref:System.Threading.Tasks.Task.Exception%2A> プロパティは null 以外になります。  
  
> [!IMPORTANT]
>  <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> プロパティの値を取得しても、タスクが完了するまで呼び出し元のスレッドはブロックされません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ThreadPool 上で実行する指定された作業をキューに配置し、その作業のタスクまたは <see cref="T:System.Threading.Tasks.Task`1" /> のハンドルを戻します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A> メソッドには、既定値を使用してタスクを簡単に開始できるようにする一連のオーバーロードが用意されています。 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> のオーバーロードに代わる軽量の方法です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberSignature Language="F#" Value="static member Run : Action -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">非同期的に実行する処理</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、その作業を表す <see cref="T:System.Threading.Tasks.Task" /> オブジェクトを戻します。</summary>
        <returns>ThreadPool で実行するためにキューに配置された作業を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A> メソッドを使用すると、1回のメソッド呼び出しでタスクを作成および実行することができます。これは、<xref:System.Threading.Tasks.TaskFactory.StartNew%2A> メソッドの代わりに、より簡単な方法です。 次の既定値を使用してタスクを作成します。  
  
-   キャンセルトークンが <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType> です。  
  
-   <xref:System.Threading.Tasks.Task.CreationOptions%2A> プロパティ値が <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。  
  
-   既定のタスクスケジューラを使用します。  
  
 タスク操作によってスローされる例外の処理の詳細については、「[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、現在のスレッドの <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> を表示する `ShowThreadInfo` メソッドを定義します。 これはアプリケーションスレッドから直接呼び出され、<xref:System.Threading.Tasks.Task.Run%28System.Action%29> メソッドに渡される <xref:System.Action> デリゲートから呼び出されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 次の例は前の例と似ていますが、ラムダ式を使用して、タスクが実行するコードを定義している点が異なります。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 この例は、非同期タスクがメインアプリケーションスレッドとは異なるスレッドで実行されることを示しています。  
  
 <xref:System.Threading.Tasks.Task.Wait%2A> メソッドを呼び出すことで、タスクが完了し、アプリケーションが終了する前にその出力が表示されるようになります。 それ以外の場合は、タスクが終了する前に `Main` メソッドが完了する可能性があります。  
  
 次の例は、<xref:System.Threading.Tasks.Task.Run%28System.Action%29> メソッドを示しています。 ディレクトリ名の配列を定義し、各ディレクトリ内のファイル名を取得するための別のタスクを開始します。 すべてのタスクは、ファイル名を1つの <xref:System.Collections.Concurrent.ConcurrentBag%601> オブジェクトに書き込みます。 この例では、<xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> メソッドを呼び出してすべてのタスクが完了したことを確認し、<xref:System.Collections.Concurrent.ConcurrentBag%601> オブジェクトに書き込まれたファイル名の総数を表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> パラメーターは <see langword="null" /> でした。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">例外処理 (タスク並列ライブラリ)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="function">非同期的に実行する処理</param>
        <summary>スレッド プール上で実行する作業を指定してキューに配置し、<paramref name="function" /> によって返されるタスクのプロキシを返します。</summary>
        <returns><paramref name="function" /> によって返されるタスクのプロキシを表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスク操作によってスローされる例外の処理の詳細については、「[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> パラメーターは <see langword="null" /> でした。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">例外処理 (タスク並列ライブラリ)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">非同期的に実行する処理</param>
        <param name="cancellationToken">処理をキャンセルするために使用できるキャンセル トークン</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、その作業を表す <see cref="T:System.Threading.Tasks.Task" /> オブジェクトを戻します。 キャンセル トークンを使うと処理をキャンセルできます。</summary>
        <returns>スレッド プールで実行するようキューに入れられた処理を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスクが実行を開始する前にキャンセルが要求された場合、タスクは実行されません。 代わりに、<xref:System.Threading.Tasks.TaskStatus.Canceled> の状態に設定され、<xref:System.Threading.Tasks.TaskCanceledException> の例外がスローされます。  
  
 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> メソッドは、<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> メソッドの代わりに、より簡単に行うことができます。 次の既定値を使用してタスクを作成します。  
  
-   <xref:System.Threading.Tasks.Task.CreationOptions%2A> プロパティ値が <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。  
  
-   既定のタスクスケジューラを使用します。  
  
 タスク操作によってスローされる例外の処理の詳細については、「[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> メソッドを呼び出して、C:\Windows\System32 ディレクトリ内のファイルを反復処理するタスクを作成します。 ラムダ式は、<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドを呼び出して、各ファイルに関する情報を <xref:System.Collections.Generic.List%601> オブジェクトに追加します。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> ループによって呼び出された、デタッチされた入れ子になった各タスクは、キャンセルトークンの状態をチェックし、キャンセルが要求された場合は <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> メソッドを呼び出します。 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> メソッドは、呼び出し元のスレッドが <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> メソッドを呼び出すと `catch` ブロックで処理される <xref:System.OperationCanceledException> 例外をスローします。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> パラメーターは <see langword="null" /> でした。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="cancellationToken" /> に関連付けられた <see cref="T:System.Threading.CancellationTokenSource" /> が破棄されました。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">例外処理 (タスク並列ライブラリ)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="function">非同期的に実行する処理。</param>
        <param name="cancellationToken">処理をキャンセルするために使う必要があるキャンセル トークン。</param>
        <summary>スレッド プール上で実行する作業を指定してキューに配置し、<paramref name="function" /> によって返されるタスクのプロキシを返します。</summary>
        <returns><paramref name="function" /> によって返されるタスクのプロキシを表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスク操作によってスローされる例外の処理の詳細については、「[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> パラメーターは <see langword="null" /> でした。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="cancellationToken" /> に関連付けられた <see cref="T:System.Threading.CancellationTokenSource" /> が破棄されました。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">タスクのキャンセル</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">例外処理 (タスク並列ライブラリ)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">プロキシ タスクによって返される結果の型。</typeparam>
        <param name="function">非同期的に実行する処理</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、<paramref name="function" /> によって返される <see langword="Task(TResult)" /> のプロキシを返します。</summary>
        <returns><see langword="Task(TResult)" /> によって返される <see langword="Task(TResult)" /> のプロキシを表す <paramref name="function" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスク操作によってスローされる例外の処理の詳細については、「[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> パラメーターは <see langword="null" /> でした。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">例外処理 (タスク並列ライブラリ)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクの戻り値の型。</typeparam>
        <param name="function">非同期的に実行する処理。</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、その作業を表す <see cref="T:System.Threading.Tasks.Task`1" /> オブジェクトを戻します。</summary>
        <returns>スレッド プールで実行するようキューに入れられた処理を表すタスク オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A> メソッドは、<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> メソッドの代わりに、より簡単に行うことができます。 次の既定値を使用してタスクを作成します。  
  
-   キャンセルトークンが <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType> です。  
  
-   <xref:System.Threading.Tasks.Task.CreationOptions%2A> プロパティ値が <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。  
  
-   既定のタスクスケジューラを使用します。  
  
 タスク操作によってスローされる例外の処理の詳細については、「[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、発行されたブックを表すテキストファイル内の単語数の概算値をカウントします。 各タスクは、ファイルを開いて、その内容全体を非同期に読み取り、正規表現を使用して単語数を計算する役割を担います。 <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> メソッドを呼び出して、各ブックのカウントをコンソールに表示する前に、すべてのタスクが完了したことを確認します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 正規表現 `\p{P}*\s+` は、0個以上の区切り文字の後に1つ以上の空白文字が続くパターンに一致します。 一致の合計数が、おおよその単語数と同じであることを前提としています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> パラメーターが <see langword="null" /> です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">例外処理 (タスク並列ライブラリ)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">プロキシ タスクによって返される結果の型。</typeparam>
        <param name="function">非同期的に実行する処理</param>
        <param name="cancellationToken">処理を取り消すために使用されるキャンセル トークン</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、<paramref name="function" /> によって返される <see langword="Task(TResult)" /> のプロキシを返します。</summary>
        <returns><see langword="Task(TResult)" /> によって返される <see langword="Task(TResult)" /> のプロキシを表す <paramref name="function" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスク操作によってスローされる例外の処理の詳細については、「[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> パラメーターは <see langword="null" /> でした。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="cancellationToken" /> に関連付けられた <see cref="T:System.Threading.CancellationTokenSource" /> が破棄されました。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">タスクのキャンセル</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">例外処理 (タスク並列ライブラリ)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクの結果の型。</typeparam>
        <param name="function">非同期的に実行する処理</param>
        <param name="cancellationToken">処理を取り消すために使用されるキャンセル トークン</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、その作業を表す <see langword="Task(TResult)" /> オブジェクトを戻します。 キャンセル トークンを使うと処理をキャンセルできます。</summary>
        <returns><see langword="Task(TResult)" /> は、スレッド プールで実行するためにキューに配置された作業を表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスクが実行を開始する前にキャンセルが要求された場合、タスクは実行されません。 代わりに、<xref:System.Threading.Tasks.TaskStatus.Canceled> の状態に設定され、<xref:System.Threading.Tasks.TaskCanceledException> の例外がスローされます。  
  
 <xref:System.Threading.Tasks.Task.Run%2A> メソッドは、<xref:System.Threading.Tasks.TaskFactory.StartNew%2A> メソッドの代わりに、より簡単に行うことができます。 次の既定値を使用してタスクを作成します。  
  
-   <xref:System.Threading.Tasks.Task.CreationOptions%2A> プロパティ値が <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。  
  
-   既定のタスクスケジューラを使用します。  
  
 タスク操作によってスローされる例外の処理の詳細については、「[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、カウンターが200万の値にインクリメントされるまでループするタスクを20個作成します。 最初の10個のタスクが200万に達した場合、キャンセルトークンは取り消され、カウンターが200万に達していないすべてのタスクは取り消されます。 この例は、考えられる出力を示しています。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 この例では、<xref:System.AggregateException.InnerExceptions%2A> プロパティを使用して例外を調べる代わりに、すべてのタスクを反復処理して、正常に完了し、取り消されたものを特定します。 完了したものについては、タスクによって返された値が表示されます。  
  
 取り消しは協調しているため、各タスクはキャンセルに応答する方法を決定できます。 次の例は最初の例と似ていますが、トークンが取り消されると、タスクは、例外をスローするのではなく、完了したイテレーションの数を返します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 この例では、キャンセルが要求されたときに開始されていないタスクも例外をスローするため、<xref:System.AggregateException> 例外を処理する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="cancellationToken" /> に関連付けられた <see cref="T:System.Threading.CancellationTokenSource" /> が破棄されました。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">タスクのキャンセル</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">例外処理 (タスク並列ライブラリ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Threading.Tasks.Task" /> で <see cref="T:System.Threading.Tasks.TaskScheduler" /> を同期的に実行します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : unit -&gt; unit" Usage="task.RunSynchronously " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.Tasks.Task" /> で <see cref="T:System.Threading.Tasks.TaskScheduler" /> を同期的に実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、タスクはスレッドプールのスレッドで非同期的に実行され、呼び出し元のスレッドはブロックされません。 <xref:System.Threading.Tasks.Task.RunSynchronously> メソッドを呼び出すことによって実行されるタスクは、現在の <xref:System.Threading.Tasks.TaskScheduler> に関連付けられ、呼び出し元のスレッドで実行されます。 ターゲットスケジューラが呼び出し元のスレッドでこのタスクの実行をサポートしていない場合は、タスクがスケジューラで実行されるようにスケジュールされ、呼び出し元のスレッドはタスクの実行が完了するまでブロックされます。 タスクが同期的に実行されている場合でも、呼び出し元のスレッドは、タスクがスローする可能性のある例外を処理するために <xref:System.Threading.Tasks.Task.Wait%2A> を呼び出す必要があります。  例外処理の詳細については、「[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。  
  
 <xref:System.Threading.Tasks.Task.RunSynchronously%2A> メソッドを呼び出すことによって実行されるタスクは、<xref:System.Threading.Tasks.Task> または <xref:System.Threading.Tasks.Task%601> クラスコンストラクターを呼び出すことによってインスタンス化されます。 同期的に実行するタスクは、<xref:System.Threading.Tasks.TaskStatus.Created> 状態である必要があります。 タスクを開始して1回だけ実行することができます。 タスクを2回目にスケジュールしようとすると、例外が発生します。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Tasks.Task.RunSynchronously%2A> メソッドを呼び出して、非同期に実行されるタスクを比較します。 どちらの場合も、タスクは、タスクが実行されているスレッドのタスク ID と ID を表示する、同一のラムダ式を実行します。 このタスクでは、1 ~ 100万の整数の合計を計算します。 この例の出力に示すように、<xref:System.Threading.Tasks.Task.RunSynchronously%2A> メソッドを呼び出すことによって実行されるタスクはアプリケーションスレッドで実行されますが、非同期タスクでは実行されません。  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> インスタンスは破棄されています。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Threading.Tasks.Task" /> は、開始する有効な状態にはありません。 既に開始、実行、またはキャンセルされたか、ダイレクト スケジューリングをサポートしない方法で作成された可能性があります。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">例外処理 (タスク並列ライブラリ)</related>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.RunSynchronously scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">このタスク インラインの実行を試みるスケジューラ。</param>
        <summary>指定された <see cref="T:System.Threading.Tasks.Task" /> で <see cref="T:System.Threading.Tasks.TaskScheduler" /> を同期的に実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.RunSynchronously%2A> メソッドを呼び出すことによって実行されるタスクは、<xref:System.Threading.Tasks.Task> または <xref:System.Threading.Tasks.Task%601> クラスコンストラクターを呼び出すことによってインスタンス化されます。 同期的に実行するタスクは、<xref:System.Threading.Tasks.TaskStatus.Created> 状態である必要があります。 タスクを開始して1回だけ実行することができます。 タスクを2回目にスケジュールしようとすると、例外が発生します。  
  
 ターゲットスケジューラが現在のスレッドでこのタスクの実行をサポートしていない場合は、タスクがスケジューラで実行されるようにスケジュールされ、現在のスレッドはタスクの実行が完了するまでブロックされます。 このため、呼び出し元のスレッドは、タスクが実行を完了したことを確認するために <xref:System.Threading.Tasks.Task.Wait%2A> などのメソッドを呼び出す必要はありません。 タスク操作の例外処理の詳細については、「[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> インスタンスは破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Threading.Tasks.Task" /> は、開始する有効な状態にはありません。 既に開始、実行、またはキャンセルされたか、ダイレクト スケジューリングをサポートしない方法で作成された可能性があります。</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">例外処理 (タスク並列ライブラリ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.Task" /> を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="task.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.Tasks.Task" /> に <see cref="T:System.Threading.Tasks.TaskScheduler" /> の実行をスケジュールし、それを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスクを開始して1回だけ実行することができます。 タスクを2回目にスケジュールしようとすると、例外が発生します。  
  
 <xref:System.Threading.Tasks.Task.Start%2A> は、<xref:System.Threading.Tasks.Task> コンストラクターのいずれかを呼び出すことによって作成されたタスクを実行するために使用されます。 これは通常、作成したタスクを条件付きで実行する場合など、タスクの作成を実行から分離する必要がある場合に行います。 タスクのインスタンス化を実行から分離する必要がない一般的なケースの場合は、<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> または <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> メソッドのオーバーロードを呼び出すことをお勧めします。  
  
 タスク操作によってスローされる例外の処理の詳細については、「[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> コンストラクターを呼び出して、タスク ID とマネージスレッド ID を表示してループを実行する新しい <xref:System.Threading.Tasks.Task> オブジェクトをインスタンス化します。 次に、<xref:System.Threading.Tasks.Task.Start%2A> メソッドを呼び出してタスクを実行します。  これはコンソールアプリであるため、タスクが実行を終了する前にアプリが終了しないようにするには、<xref:System.Threading.Tasks.Task.Wait%2A> メソッドを呼び出す必要があります。  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> インスタンスは破棄されています。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Threading.Tasks.Task" /> は、開始する有効な状態にはありません。 既に開始、実行、またはキャンセルされたか、ダイレクト スケジューリングをサポートしない方法で作成された可能性があります。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">例外処理 (タスク並列ライブラリ)</related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.Start : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.Start scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">このタスクを関連付けて実行する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>指定された <see cref="T:System.Threading.Tasks.Task" /> に <see cref="T:System.Threading.Tasks.TaskScheduler" /> の実行をスケジュールし、それを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タスクを開始して実行できるのは一度だけです。 タスクを2回目にスケジュールしようとすると、例外が発生します。  
  
 タスク操作によってスローされる例外の処理の詳細については、「[例外処理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Threading.Tasks.Task" /> は、開始する有効な状態にはありません。 既に開始、実行、またはキャンセルされたか、ダイレクト スケジューリングをサポートしない方法で作成された可能性があります。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> インスタンスは破棄されています。</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">スケジューラは、このタスクをキューに入れられませんでした。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">例外処理 (タスク並列ライブラリ)</related>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberSignature Language="F#" Value="member this.Status : System.Threading.Tasks.TaskStatus" Usage="System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このタスクの <see cref="T:System.Threading.Tasks.TaskStatus" /> を取得します。</summary>
        <value>このタスク インスタンスの現在の <see cref="T:System.Threading.Tasks.TaskStatus" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> プロパティの値を取得しても、タスクが完了するまで呼び出し元のスレッドはブロックされません。  
  
 詳細と例については、「[継続タスクを使用](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)したタスクの連結」と「[方法: タスクとその子を取り消す](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、カウンターが200万の値にインクリメントされるまでループするタスクを20個作成します。 最初の10個のタスクが200万に達した場合、キャンセルトークンは取り消され、カウンターが200万に達していないすべてのタスクは取り消されます。 この例では、各タスクの <xref:System.Threading.Tasks.Task.Status%2A> プロパティを調べて、正常に完了したか取り消されたかを示します。 完了したものについては、タスクによって返された値が表示されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System::IAsyncResult::AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タスクの完了を待機するために使用できる <see cref="T:System.Threading.WaitHandle" /> を取得します。</summary>
        <value>タスクの完了を待機するために使用できる <see cref="T:System.Threading.WaitHandle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> によって提供される待機機能を使用すると、同様の機能に <xref:System.IAsyncResult.AsyncWaitHandle%2A> を使用することをお勧めします。 詳細については、「[タスクベースの非同期プログラミング](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)」の「タスクを待機中」と、[他の非同期パターンで TPL を使用する方法](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md)に関するセクションを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::IAsyncResult::CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>操作が同期的に完了したかどうかを示す値を取得します。</summary>
        <value>操作が同期的に完了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで待機します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="task.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで待機します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A> は、現在のタスクが完了するまで呼び出し元のスレッドを待機させる同期メソッドです。 現在のタスクが実行を開始していない場合、Wait メソッドはスケジューラからタスクを削除し、現在のスレッドでインラインで実行しようとします。 それができない場合、または現在のタスクが既に実行を開始している場合は、タスクが完了するまで呼び出し元のスレッドがブロックされます。 詳細については、「.NET を使用した並列プログラミング」ブログの「 [Task. Wait」と「インライン展開」](https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/)を参照してください。   
  
## Examples  
 次の例では、0と100の間に100万のランダムな整数を生成し、その平均値を計算するタスクを開始します。 この例では、<xref:System.Threading.Tasks.Task.Wait%2A> メソッドを使用して、アプリケーションが終了する前にタスクが完了するようにします。 それ以外の場合、これはコンソールアプリケーションであるため、この例はタスクが計算して平均値を表示する前に終了します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。 <see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.Threading.Tasks.TaskCanceledException" /> オブジェクトが含まれています。  
  
- または - 
タスクの実行時に例外がスローされました。 <see cref="P:System.AggregateException.InnerExceptions" /> コレクションには、例外に関する情報が含まれています。</exception>
        <related type="ExternalDocumentation" href="https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/">タスク。待機と "インライン展開"</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="task.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>提供された <see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで、指定したミリ秒数以内の間、待機します。</summary>
        <returns>割り当てられた時間内に <see langword="true" /> の実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> は、次のいずれかが発生するまで、呼び出し元のスレッドが現在のタスクインスタンスの完了を待機する同期メソッドです。  
  
-   タスクが正常に完了しました。  
  
-   タスク自体が取り消されたか、例外がスローされました。 この場合、<xref:System.AggregateException> 例外を処理します。 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> プロパティには、例外または例外の詳細が含まれます。  
  
-   `millisecondsTimeout` によって定義された間隔が経過した。 この場合、現在のスレッドは実行を再開し、メソッドは `false` を返します。  
  
   
  
## Examples  
 次の例では、0と100の間に500万のランダムな整数を生成し、その平均値を計算するタスクを開始します。 この例では、<xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> メソッドを使用して、アプリケーションが150ミリ秒以内に完了するまで待機します。 アプリケーションが正常に完了した場合、タスクでは、生成された乱数の合計と平均が表示されます。 タイムアウト間隔が経過した場合、この例ではメッセージが終了する前に表示されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。 <see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.Threading.Tasks.TaskCanceledException" /> オブジェクトが含まれています。  
  
- または - 
タスクの実行時に例外がスローされました。 <see cref="P:System.AggregateException.InnerExceptions" /> コレクションには、例外に関する情報が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="task.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">タスクの完了の待機中に観察するキャンセル トークン。</param>
        <summary><see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで待機します。 タスクの完了前にキャンセル トークンが取り消される場合は、待機が終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> メソッドは、キャンセル可能な待機を作成します。つまり、次のいずれかが発生するまで、現在のスレッドは待機状態になります。  
  
-   タスクが完了します。  
  
-   キャンセルトークンが取り消されました。 この場合、<xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> メソッドを呼び出すと、<xref:System.OperationCanceledException> がスローされます。  
  
> [!NOTE]
>  キャンセルトークンがキャンセルトークンに渡され、キャンセルを処理できるように準備されている場合を除き、`cancellationToken` キャンセルトークンをキャンセルしても、実行中のタスクには影響しません。 `cancellationToken` オブジェクトをこのメソッドに渡すだけで、待機を取り消すことができます。  
  
   
  
## Examples  
 次の例では、キャンセルトークンを使用してタスクの完了を待機する方法を簡単に説明します。 タスクが起動され、<xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> メソッドを呼び出してトークンソースのキャンセルトークンをキャンセルし、5秒間遅延します。 タスク自体にキャンセルトークンが渡されておらず、キャンセルできないことに注意してください。 アプリケーションスレッドはタスクの <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> メソッドを呼び出してタスクの完了を待機しますが、キャンセルトークンが取り消され、<xref:System.OperationCanceledException> がスローされると待機がキャンセルされます。 例外ハンドラーは例外を報告し、6秒間スリープします。 この例の出力に示されているように、この遅延により、タスクは <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 状態で完了できます。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> は取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException">タスクが破棄されました。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。 <see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.Threading.Tasks.TaskCanceledException" /> オブジェクトが含まれています。  
  
- または - 
タスクの実行時に例外がスローされました。 <see cref="P:System.AggregateException.InnerExceptions" /> コレクションには、例外に関する情報が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="task.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary>提供された <see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで、指定した時間間隔内の間、待機します。</summary>
        <returns>割り当てられた時間内に <see langword="true" /> の実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> は、次のいずれかが発生するまで、呼び出し元のスレッドが現在のタスクインスタンスの完了を待機する同期メソッドです。  
  
-   タスクが正常に完了しました。  
  
-   タスク自体が取り消されたか、例外がスローされました。 この場合、<xref:System.AggregateException> 例外を処理します。 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> プロパティには、例外または例外の詳細が含まれます。  
  
-   `timeout` によって定義された間隔が経過した。 この場合、現在のスレッドは実行を再開し、メソッドは `false` を返します。  
  
   
  
## Examples  
 次の例では、0と100の間に500万のランダムな整数を生成し、その平均値を計算するタスクを開始します。 この例では、<xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> メソッドを使用して、アプリケーションが150ミリ秒以内に完了するまで待機します。 アプリケーションが正常に完了した場合、タスクでは、生成された乱数の合計と平均が表示されます。 タイムアウト間隔が経過した場合、この例ではメッセージが終了する前に表示されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。 
- または - 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。 <see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.Threading.Tasks.TaskCanceledException" /> オブジェクトが含まれています。  
  
- または - 
タスクの実行時に例外がスローされました。 <see cref="P:System.AggregateException.InnerExceptions" /> コレクションには、例外に関する情報が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="task.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="cancellationToken">タスクの完了の待機中に観察するキャンセル トークン。</param>
        <summary><see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで待機します。 タスクの完了前に、タイムアウト期間が経過するか、キャンセル トークンが取り消される場合には、待機が終了します。</summary>
        <returns>割り当てられた時間内に <see langword="true" /> の実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> は、次のいずれかが発生するまで、呼び出し元のスレッドが現在のタスクインスタンスの完了を待機する同期メソッドです。  
  
-   タスクが正常に完了しました。  
  
-   タスク自体が取り消されたか、例外がスローされました。 この場合、<xref:System.AggregateException> 例外を処理します。 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> プロパティには、例外または例外の詳細が含まれます。  
  
-   `cancellationToken` キャンセルトークンが取り消されました。 この場合、<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> メソッドを呼び出すと、<xref:System.OperationCanceledException> がスローされます。  
  
-   `millisecondsTimeout` によって定義された間隔が経過した。 この場合、現在のスレッドは実行を再開し、メソッドは `false` を返します。  
  
> [!NOTE]
>  キャンセルトークンがキャンセルトークンに渡され、キャンセルを処理できるように準備されている場合を除き、`cancellationToken` キャンセルトークンをキャンセルしても、実行中のタスクには影響しません。 `cancellationToken` オブジェクトをこのメソッドに渡すだけで、何らかの条件に基づいて待機を取り消すことができます。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> メソッドを呼び出して、タイムアウト値と、タスクの完了の待機を終了できるキャンセルトークンの両方を提供しています。 新しいスレッドが開始され、`CancelToken` メソッドを実行します。このメソッドは、を一時停止し、<xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> メソッドを呼び出してキャンセルトークンをキャンセルします。 タスクが起動され、5秒間遅延します。 次に、<xref:System.Threading.Tasks.Task.Wait%2A> メソッドを呼び出してタスクの完了を待機し、短いタイムアウト値とキャンセルトークンの両方を提供します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 この例の正確な出力は、キャンセルトークンによって、またはタイムアウト間隔が経過したために待機がキャンセルされたかどうかによって異なります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> は取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。 <see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.Threading.Tasks.TaskCanceledException" /> オブジェクトが含まれています。  
  
- または - 
タスクの実行時に例外がスローされました。 <see cref="P:System.AggregateException.InnerExceptions" /> コレクションには、例外に関する情報が含まれています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>提供されたすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <summary>指定したすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、10個のタスクを開始します。各タスクには、状態オブジェクトとしてインデックスが渡されます。 2 ~ 5 のインデックスを持つタスクは、例外をスローします。 <xref:System.Threading.Tasks.Task.WaitAll%2A> メソッドを呼び出すと、すべての例外が <xref:System.AggregateException> オブジェクトにラップされ、呼び出し元のスレッドに反映されます。  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合は、<see cref="T:System.AggregateException" /> 例外の <see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.OperationCanceledException" /> 例外が格納されます。  
  
- または - 
少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>提供されたすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで、指定したミリ秒数以内の間、待機します。</summary>
        <returns>割り当てられた時間内に <see langword="true" /> インスタンスすべての実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合、<see cref="T:System.AggregateException" /> の <see cref="T:System.OperationCanceledException" /> コレクションには <see cref="P:System.AggregateException.InnerExceptions" /> が含まれます。  
  
- または - 
少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="cancellationToken">タスクの完了を待機しているときに観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>待機が取り消されない限り、指定したすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `cancellationToken` 引数は、待機操作を取り消すために使用されます。 タスクの取り消しは個別の操作であり、前述のように <xref:System.AggregateException> によって通知されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> は取り消されました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合、<see cref="T:System.AggregateException" /> の <see cref="T:System.OperationCanceledException" /> コレクションには <see cref="P:System.AggregateException.InnerExceptions" /> が含まれます。  
  
- または - 
少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * TimeSpan -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary>提供されたすべてのキャンセル可能な <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで、指定した時間間隔の間、待機します。</summary>
        <returns>割り当てられた時間内に <see langword="true" /> インスタンスすべての実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合、<see cref="T:System.AggregateException" /> の <see cref="T:System.OperationCanceledException" /> コレクションには <see cref="P:System.AggregateException.InnerExceptions" /> が含まれます。  
  
- または - 
少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。 
- または - 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="cancellationToken">タスクの完了を待機しているときに観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>指定したミリ秒数まで、または待機が取り消されるまで、提供されたすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するのを待機します。</summary>
        <returns>割り当てられた時間内に <see langword="true" /> インスタンスすべての実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `cancellationToken` 引数は、待機操作を取り消すために使用されます。 タスクの取り消しは個別の操作であり、上記の <xref:System.AggregateException> によって通知されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合、<see cref="T:System.AggregateException" /> の <see cref="T:System.OperationCanceledException" /> コレクションには <see cref="P:System.AggregateException.InnerExceptions" /> が含まれます。  
  
- または - 
少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> は取り消されました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <summary>指定したいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
        <returns><paramref name="tasks" /> 配列内の完了した <see cref="T:System.Threading.Tasks.Task" /> オブジェクトのインデックス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、5つのタスクを起動します。各タスクは最低50ミリ秒、または最大1050ミリ秒間スリープします。 <xref:System.Threading.Tasks.Task.WaitAny%2A> メソッドは、いずれかのタスクが完了するまで待機します。 この例では、待機を終了したタスクのタスク ID と、すべてのタスクの現在の状態が表示されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>提供されたいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで、指定したミリ秒数以内の間、待機します。</summary>
        <returns><paramref name="tasks" /> 配列引数内の完了したタスクのインデックス。タイムアウトが発生した場合は -1。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="cancellationToken">タスクの完了を待機しているときに監視する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>待機が取り消されない限り、指定したいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
        <returns><paramref name="tasks" /> 配列引数内の完了したタスクのインデックス。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> は取り消されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * TimeSpan -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary>提供されたいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで、指定した時間間隔内の間、待機します。</summary>
        <returns><paramref name="tasks" /> 配列引数内の完了したタスクのインデックス。タイムアウトが発生した場合は -1。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 引数の <see cref="P:System.TimeSpan.TotalMilliseconds" /> プロパティは、-1 (無制限のタイムアウトを表す) 以外の負の数です。 
- または - 
<paramref name="timeout" /> 引数の <see cref="P:System.TimeSpan.TotalMilliseconds" /> プロパティが <see cref="F:System.Int32.MaxValue" /> より大きい値です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="cancellationToken">タスクの完了を待機しているときに監視する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>指定したミリ秒数まで、または待機トークンが取り消されるまで、提供されたいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するのを待機します。</summary>
        <returns><paramref name="tasks" /> 配列引数内の完了したタスクのインデックス。タイムアウトが発生した場合は -1。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> は取り消されました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたすべてのタスクが完了してから完了するタスクを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>列挙可能なコレクション内のすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが完了したときに完了するタスクを作成します。</summary>
        <returns>指定されたすべてのタスクの完了を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task> オブジェクトを返す <xref:System.Threading.Tasks.Task.WhenAll%2A> メソッドのオーバーロードは、通常、一連のタスクの状態または一連のタスクによってスローされた例外に関心がある場合に呼び出されます。  
  
> [!NOTE]
>  <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> メソッドを呼び出すと、呼び出し元のスレッドがブロックされません。  
  
 指定されたいずれかのタスクが faulted 状態で完了した場合、返されたタスクも <xref:System.Threading.Tasks.TaskStatus.Faulted> 状態で完了します。この場合、例外には、指定された各タスクからのラップされていない一連の例外の集計が含まれます。  
  
 指定されたタスクがいずれも失敗しても、そのうち少なくとも1つが取り消された場合、返されたタスクは <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態で終了します。  
  
 タスクにエラーが発生しておらず、どのタスクも取り消されなかった場合、結果として得られるタスクは <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 状態で終了します。  
  
 指定した配列または列挙可能なにタスクが含まれていない場合、返されたタスクは、呼び出し元に返される前に、直ちに <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 状態に移行します。  
  
   
  
## Examples  
 次の例では、配列内の Url に ping を行う一連のタスクを作成します。 タスクは、<xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> メソッドに渡される `List<Task>` コレクションに格納されます。 <xref:System.Threading.Tasks.Task.Wait%2A> メソッドを呼び出してすべてのスレッドが完了したことを確認した後、この例では <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> プロパティを調べて、いずれかのタスクが失敗したかどうかを判断します。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> でした。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> コレクションに <see langword="null" /> タスクが含まれていました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>配列内のすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが完了したときに完了するタスクを作成します。</summary>
        <returns>指定されたすべてのタスクの完了を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task> オブジェクトを返す <xref:System.Threading.Tasks.Task.WhenAll%2A> メソッドのオーバーロードは、通常、一連のタスクの状態または一連のタスクによってスローされた例外に関心がある場合に呼び出されます。  
  
> [!NOTE]
>  <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> メソッドを呼び出すと、呼び出し元のスレッドがブロックされません。  
  
 指定されたいずれかのタスクが faulted 状態で完了した場合、返されたタスクも <xref:System.Threading.Tasks.TaskStatus.Faulted> 状態で完了します。この場合、例外には、指定された各タスクからのラップされていない一連の例外の集計が含まれます。  
  
 指定されたタスクがいずれも失敗しても、そのうち少なくとも1つが取り消された場合、返されたタスクは <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態で終了します。  
  
 タスクにエラーが発生しておらず、どのタスクも取り消されなかった場合、結果として得られるタスクは <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 状態で終了します。  
  
 指定した配列または列挙可能なにタスクが含まれていない場合、返されたタスクは、呼び出し元に返される前に、直ちに <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 状態に移行します。  
  
   
  
## Examples  
 次の例では、配列内の Url に ping を行う一連のタスクを作成します。 タスクは、配列に変換され、<xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> メソッドに渡される `List<Task>` コレクションに格納されます。 <xref:System.Threading.Tasks.Task.Wait%2A> メソッドを呼び出してすべてのスレッドが完了したことを確認した後、この例では <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> プロパティを調べて、いずれかのタスクが失敗したかどうかを判断します。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> でした。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 配列に <see langword="null" /> タスクが含まれていました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">完了したタスクの型。</typeparam>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>列挙可能なコレクション内のすべての <see cref="T:System.Threading.Tasks.Task`1" /> オブジェクトが完了したときに完了するタスクを作成します。</summary>
        <returns>指定されたすべてのタスクの完了を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> メソッドを呼び出すと、呼び出し元のスレッドがブロックされません。 ただし、返された <xref:System.Threading.Tasks.Task%601.Result%2A> プロパティを呼び出すと、呼び出し元のスレッドがブロックされます。  
  
 指定されたいずれかのタスクが faulted 状態で完了した場合、返されたタスクも <xref:System.Threading.Tasks.TaskStatus.Faulted> 状態で完了します。この場合、例外には、指定された各タスクからのラップされていない一連の例外の集計が含まれます。  
  
 指定されたタスクがいずれも失敗しても、そのうち少なくとも1つが取り消された場合、返されたタスクは <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態で終了します。  
  
 タスクにエラーが発生しておらず、どのタスクも取り消されなかった場合、結果として得られるタスクは <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 状態で終了します。  返されたタスクの <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> プロパティは、指定されたタスクのすべての結果を含む配列に設定されます。たとえば、入力タスク配列に t1、t2、t3 が含まれている場合、出力タスクの <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> プロパティはを @no__t_2 返します。_ `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`。`TResult[]`  
  
 `tasks` 引数にタスクが含まれていない場合、返されたタスクは、呼び出し元に返される前に、直ちに <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 状態に遷移します。 返された `TResult[]` は、0個の要素の配列になります。  
  
   
  
## Examples  
 次の例では、10個のタスクを作成し、1 ~ 1000 の範囲で1000の乱数を作成し、平均を計算する乱数ジェネレーターをインスタンス化します。 <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> メソッドは、乱数ジェネレーターのインスタンス化を遅延させ、同じシード値で作成されないようにするために使用します。 <xref:System.Threading.Tasks.Task.WhenAll%2A> メソッドを呼び出すと、各タスクによって計算された平均値を含む <xref:System.Int64> 配列が返されます。 これらは、全体の平均を計算するために使用されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 この場合、10個の個別のタスクが <xref:System.Collections.Generic.List%601> オブジェクトに格納されます。 <xref:System.Collections.Generic.List%601> では、<xref:System.Collections.Generic.IEnumerable%601> インターフェイスを実装します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> でした。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> コレクションに <see langword="null" /> タスクが含まれていました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">完了したタスクの型。</typeparam>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>配列内のすべての <see cref="T:System.Threading.Tasks.Task`1" /> オブジェクトが完了したときに完了するタスクを作成します。</summary>
        <returns>指定されたすべてのタスクの完了を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> メソッドを呼び出すと、呼び出し元のスレッドがブロックされません。 ただし、返された <xref:System.Threading.Tasks.Task%601.Result%2A> プロパティを呼び出すと、呼び出し元のスレッドがブロックされます。  
  
 指定されたいずれかのタスクが faulted 状態で完了した場合、返されたタスクも <xref:System.Threading.Tasks.TaskStatus.Faulted> 状態で完了します。この場合、例外には、指定された各タスクからのラップされていない一連の例外の集計が含まれます。  
  
 指定されたタスクがいずれも失敗しても、そのうち少なくとも1つが取り消された場合、返されたタスクは <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態で終了します。  
  
 タスクにエラーが発生しておらず、どのタスクも取り消されなかった場合、結果として得られるタスクは <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 状態で終了します。  返されたタスクの <xref:System.Threading.Tasks.Task%601.Result%2A> は、指定されたタスクのすべての結果を含む配列に設定されます。たとえば、入力タスク配列に t1、t2、t3 が含まれている場合、出力タスクの <xref:System.Threading.Tasks.Task%601.Result%2A> は `TResult[]` を返し `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 指定した配列または列挙可能なにタスクが含まれていない場合、返されたタスクは、呼び出し元に返される前に、直ちに <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 状態に移行します。  返された `TResult[]` は、0個の要素の配列になります。  
  
   
  
## Examples  
 次の例では、10個のタスクを作成し、1 ~ 1000 の範囲で1000の乱数を作成し、平均を計算する乱数ジェネレーターをインスタンス化します。 この場合、10個の個別のタスクが `Task<Int64>` 配列に格納されます。  <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> メソッドは、乱数ジェネレーターのインスタンス化を遅延させ、同じシード値で作成されないようにするために使用します。 <xref:System.Threading.Tasks.Task.WhenAll%2A> メソッドを呼び出すと、各タスクによって計算された平均値を含む <xref:System.Int64> 配列が返されます。 これらは、全体の平均を計算するために使用されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> でした。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 配列に <see langword="null" /> タスクが含まれていました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたタスクのいずれかが完了してから完了するタスクを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>指定されたタスクのいずれかが完了してから完了するタスクを作成します。</summary>
        <returns>指定されたいずれかのタスクの完了を表すタスク。  返されるタスクの結果は完了したタスクです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたタスクのいずれかが完了すると、返されたタスクが完了します。  返されたタスクは常に、最初のタスクが完了するまでの結果セットと共に `RanToCompletion` 状態で終了します。  これは、最初のタスクが完了したときに、`Canceled` または `Faulted` の状態で終了した場合にも当てはまります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> でした。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 配列に null タスクが含まれていたか、空でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>指定されたタスクのいずれかが完了してから完了するタスクを作成します。</summary>
        <returns>指定されたいずれかのタスクの完了を表すタスク。  返されるタスクの結果は完了したタスクです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたタスクのいずれかが完了すると、返されたタスクが完了します。  返されたタスクは常に、最初のタスクが完了するように設定された `Result` と共に `RanToCompletion` 状態で終了します。  これは、最初のタスクが完了したときに、`Canceled` または `Faulted` の状態で終了した場合にも当てはまります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が null でした。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 配列に null タスクが含まれていたか、空でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">完了したタスクの型。</typeparam>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>指定されたタスクのいずれかが完了してから完了するタスクを作成します。</summary>
        <returns>指定されたいずれかのタスクの完了を表すタスク。  返されるタスクの結果は完了したタスクです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたタスクのいずれかが完了すると、返されたタスクが完了します。  返されたタスクは、最初のタスクが完了するまでの結果セットと共に、常に RanToCompletion 状態で終了します。 これは、最初のタスクが取り消された状態または Faulted 状態で終了した場合でも当てはまります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が <see langword="null" /> でした。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 配列に null タスクが含まれていたか、空でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">完了したタスクの型。</typeparam>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>指定されたタスクのいずれかが完了してから完了するタスクを作成します。</summary>
        <returns>指定されたいずれかのタスクの完了を表すタスク。  返されるタスクの結果は完了したタスクです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたタスクのいずれかが完了すると、返されたタスクが完了します。  返されたタスクは、最初のタスクが完了するまでの結果セットと共に、常に RanToCompletion 状態で終了します。 これは、最初のタスクが取り消された状態または Faulted 状態で終了した場合でも当てはまります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 引数が null でした。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 配列に null タスクが含まれていたか、空でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Runtime.CompilerServices.YieldAwaitable" Usage="System.Threading.Tasks.Task.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>待機されたときに現在のコンテキストに非同期的に処理を譲る awaitable タスクを作成します。</summary>
        <returns>必要な場合は、要求時に現在のコンテキストに非同期で再度遷移するコンテキスト。 現在の <see cref="T:System.Threading.SynchronizationContext" /> が null 以外の場合は、現在のコンテキストとして扱われます。 それ以外の場合は、現在の実行タスクに関連付けられているタスク スケジューラは、現在のコンテキストとして扱われます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期メソッドで `await Task.Yield();` を使用して、メソッドを強制的に非同期的に完了させることができます。 現在の同期コンテキスト (<xref:System.Threading.SynchronizationContext> オブジェクト) がある場合は、メソッドの残りの実行がそのコンテキストにポストされます。 ただし、コンテキストによって、保留中の他の作業と比較して、この作業の優先順位を決定する方法が決まります。 ほとんどの UI 環境で UI スレッドに存在する同期コンテキストでは、多くの場合、入力およびレンダリング作業よりも高いコンテキストにポストされた作業の優先順位が付けられます。 このため、UI の応答性を維持するために `await Task.Yield();` に依存しないでください。  詳細については、.NET の並列プログラミングに関するブログの「 [system.threading.tasks.task.continuewith で有効な抽象化が有効になっている](https://devblogs.microsoft.com/pfxteam/useful-abstractions-enabled-with-continuewith/)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
