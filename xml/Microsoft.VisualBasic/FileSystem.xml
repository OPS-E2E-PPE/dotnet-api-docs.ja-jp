<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1f940726ccb01e692538ad14f77890b52044c8de" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83954692" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed FileSystem extends System.Object" FrameworkAlternate="netframework-1.1" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
    <AssemblyVersion>10.0.5.0</AssemblyVersion>
    <AssemblyVersion>10.0.6.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see langword="FileSystem" /> モジュールに含まれるプロシージャを使って、ファイル、ディレクトリ、またはフォルダー、およびシステムの操作を実行します。 <see langword="My" /> 機能を使用すると、<see langword="FileSystem" /> モジュールを使用した場合よりファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このモジュールは、ファイルとフォルダーにアクセスする Visual Basic 言語キーワードとランタイムライブラリメンバーをサポートしています。  
  
   
  
## Examples  
 この例では、`GetAttr` 関数を使用して、ファイル、ディレクトリ、またはフォルダーの属性を決定します。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="/dotnet/visual-basic/language-reference/keywords/directories-and-files-summary">ディレクトリとファイルの概要</related>
    <related type="Article" href="/dotnet/visual-basic/language-reference/keywords/input-and-output-summary">入出力の概要</related>
    <related type="Article" href="/dotnet/visual-basic/language-reference/keywords/">キーワード (Visual Basic)</related>
    <related type="Article" href="/dotnet/visual-basic/language-reference/runtime-library-members">ランタイムライブラリのメンバーの Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChDir(string Path) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必須。 新しい既定ディレクトリまたはフォルダーになるディレクトリまたはフォルダーを識別する文字列式です。 <paramref name="Path" /> にはドライブを含めることができます。 ドライブを指定しない場合、<see langword="ChDir" /> は現在のドライブの既定ディレクトリまたは既定フォルダーを変更します。</param>
        <summary>現在のディレクトリまたはフォルダーを変更します。 <see langword="My" /> 機能を使用すると、<see langword="ChDir" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir` 関数は既定のディレクトリを変更しますが、既定のドライブは変更しません。 たとえば、既定のドライブが C の場合、次のステートメントではドライブ D の既定のディレクトリが変更されますが、C は既定のドライブのままです。  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 相対ディレクトリを変更するには、次のように2つのピリオドを入力します。  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir` 関数には、部分信頼状況での実行に影響する可能性があるアンマネージコードのアクセス許可が必要です。 詳細については、「」および「<xref:System.Security.Permissions.SecurityPermission>」を参照してください。  
  
   
  
## Examples  
 この例では、`ChDir` 関数を使用して、現在のディレクトリまたはフォルダーを変更します。  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> が空です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">指定されたドライブが無効です。または利用できません。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths">方法 : Visual Basic でファイル パスを解析する</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Visual Basic でのファイルおよびディレクトリの作成、削除、および移動</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のドライブを変更します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChDrive(char Drive) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">必須。 既存のドライブを指定する文字列式。 長さ 0 の文字列 ("") を指定した場合、現在のドライブは変更されません。 <paramref name="Drive" /> 引数が複数の文字で構成される文字列の場合、<see langword="ChDrive" /> は先頭の文字だけを使用します。</param>
        <summary>現在のドライブを変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` 関数には、部分信頼状態での実行に影響する可能性があるアンマネージコードのアクセス許可が必要です。 詳細については、「<xref:System.Security.Permissions.SecurityPermission>」および「[コードアクセス許可](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)」を参照してください。  
  
   
  
## Examples  
 この例では、`ChDrive` 関数を使用して現在のドライブを変更します。 この関数は、ドライブが存在しない場合に例外をスローします。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定されたドライブが無効です。または利用できません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChDrive(string Drive) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">必須。 既存のドライブを指定する文字列式。 長さ 0 の文字列 ("") を指定した場合、現在のドライブは変更されません。 <paramref name="Drive" /> 引数が複数の文字で構成される文字列の場合、<see langword="ChDrive" /> は先頭の文字だけを使用します。</param>
        <summary>現在のドライブを変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` 関数には、部分信頼状態での実行に影響する可能性があるアンマネージコードのアクセス許可が必要です。 詳細については、「<xref:System.Security.Permissions.SecurityPermission>」および「[コードアクセス許可](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)」を参照してください。  
  
   
  
## Examples  
 この例では、`ChDrive` 関数を使用して現在のドライブを変更します。 この関数は、ドライブが存在しない場合に例外をスローします。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定されたドライブが無効です。または利用できません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のパスを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="CurDir" /> を使用した場合よりも、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CurDir() cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のパスを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="CurDir" /> を使用した場合よりも、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> を参照してください。</summary>
        <returns>現在のパスを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では、`CurDir` 関数を使用して現在のパスを返します。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CurDir(char Drive) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">省略可能。 既存のドライブを指定する <see langword="Char" /> 式です。 ドライブが指定されていない場合、または <paramref name="Drive" /> が長さ 0 の文字列 ("") である場合は、<see langword="CurDir" /> により現在のドライブのパスが返されます。</param>
        <summary>現在のパスを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="CurDir" /> を使用した場合よりも、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> を参照してください。</summary>
        <returns>現在のパスを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では、`CurDir` 関数を使用して現在のパスを返します。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定パターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="Dir" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> 」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir() cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指定パターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="Dir" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> 」を参照してください。</summary>
        <returns>指定されたパターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir` 関数では、複数のファイルを指定するために複数の文字 (`*`) と1文字の (`?`) ワイルドカードを使用できます。  
  
 `VbVolume` は、特定のファイル名ではなく、ドライブのボリュームラベルを返します。  
  
 `Dir` 関数を初めて呼び出すときは、`PathName` を指定する必要があります。 次の項目を取得するには、パラメーターを指定せずに `Dir` 関数への後続の呼び出しを行うことができます。  
  
> [!IMPORTANT]
>  正常に実行するには、`Dir` 関数で、実行中のコードに対して <xref:System.Security.Permissions.FileIOPermission> の <xref:System.Security.Permissions.FileIOPermissionAccess.Read> と <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> フラグを与える必要があります。 詳細については、「<xref:System.Security.Permissions.FileIOPermission>、<xref:System.Security.SecurityException>、および[コードアクセス許可](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)」を参照してください。  
  
 `Attributes` 引数の列挙値は次のとおりです。  
  
|値|常時|説明|  
|-|-|-|  
|`Normal`|`vbnormal`|既定値。 属性のないファイルを指定します。|  
|`ReadOnly`|`vbReadOnly`|読み取り専用ファイルと、属性のないファイルを指定します。|  
|`Hidden`|`vbHidden`|隠しファイル、および属性のないファイルを指定します。|  
|`System`|`vbSystem`|システムファイル、および属性のないファイルを指定します。|  
|`Volume`|`vbVolume`|ボリュームラベルを指定します。他の属性が指定されている場合、`vbVolume` は無視されます。|  
|`Directory`|`vbDirectory`|ディレクトリまたはフォルダー、および属性のないファイルを指定します。|  
|`Archive`|`vbArchive`|ファイルは前回のバックアップ以降に変更されています。|  
|`Alias`|`vbAlias`|ファイルに別の名前が付いています。|  
  
> [!NOTE]
>  これらの列挙は Visual Basic 言語によって指定され、実際の値の代わりにコード内の任意の場所で使用できます。  
  
   
  
## Examples  
 この例では、`Dir` 関数を使用して、特定のファイルとディレクトリが存在するかどうかを確認します。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">省略可能。 ファイル名、ディレクトリまたはフォルダー名、あるいはドライブ ボリューム ラベルを指定する文字列式です。 <paramref name="PathName" /> が見つからない場合は、長さ 0 の文字列 (<see langword="&quot;&quot;" />) が返されます。</param>
        <param name="Pathname">省略可能。 ファイル名、ディレクトリまたはフォルダー名、あるいはドライブ ボリューム ラベルを指定する文字列式です。 <paramref name="Pathname" /> が見つからない場合は、長さ 0 の文字列 (<see langword="&quot;&quot;" />) が返されます。</param>
        <param name="Attributes">省略可能。 値がファイル属性を指定する列挙式または数式。 省略した場合、<see langword="Dir" /> は、<paramref name="Pathname" /> に一致する、属性のないファイルを返します。</param>
        <summary>指定パターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="Dir" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> 」を参照してください。</summary>
        <returns>指定されたパターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir` 関数では、複数のファイルを指定するために複数の文字 (`*`) と1文字の (`?`) ワイルドカードを使用できます。  
 `VbVolume` は、特定のファイル名ではなく、ドライブのボリュームラベルを返します。  
 `Dir` 関数を初めて呼び出すときは、`PathName` を指定する必要があります。 次の項目を取得するには、パラメーターを使用せずに `Dir` 関数への後続の呼び出しを行うことができます。  
> [!IMPORTANT]
>  正常に実行するには、`Dir` 関数で、実行中のコードに対して <xref:System.Security.Permissions.FileIOPermission> の <xref:System.Security.Permissions.FileIOPermissionAccess.Read> と <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> フラグを与える必要があります。 詳細については、「<xref:System.Security.Permissions.FileIOPermission>、<xref:System.Security.SecurityException>、および[コードアクセス許可](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)」を参照してください。  
 `Attributes` 引数の列挙値は次のとおりです。  
|値|常時|説明|  
|-|-|-|  
|`Normal`|`vbnormal`|既定値。 属性を持たないファイルを指定します。|  
|`ReadOnly`|`vbReadOnly`|属性を持たないファイルに加えて、読み取り専用ファイルを指定します。|  
|`Hidden`|`vbHidden`|属性を持たないファイルに加えて、隠しファイルを指定します。|  
|`System`|`vbSystem`|属性を持たないファイルに加えて、システムファイルを指定します。|  
|`Volume`|`vbVolume`|ボリュームラベルを指定します。他の属性が指定されている場合、`vbVolume` は無視されます。|  
|`Directory`|`vbDirectory`|属性を持たないファイルに加えて、ディレクトリまたはフォルダーを指定します。|  
|`Archive`|`vbArchive`|ファイルは前回のバックアップ以降に変更されています。|  
|`Alias`|`vbAlias`|ファイルに別の名前が付いています。|  
> [!NOTE]
>  これらの列挙は Visual Basic 言語によって指定され、実際の値の代わりにコード内の任意の場所で使用できます。  
## Examples  
 この例では、`Dir` 関数を使用して、特定のファイルとディレクトリが存在するかどうかを確認します。  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EOF(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 有効なファイル番号が含まれている <see langword="Integer" /> 型の値。</param>
        <summary><see langword="True" /> モードまたはシーケンシャル <see langword="Random" /> モードで開いたファイルの現在位置がファイルの末尾に達している場合、ブール値 <see langword="Input" /> を返します。</summary>
        <returns><see langword="True" /> モードまたはシーケンシャル <see langword="Random" /> モードで開いたファイルの現在位置がファイルの末尾に達している場合、ブール値 <see langword="Input" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイルの末尾を越えて入力を取得しようとしたときに発生したエラーを回避するには、`EOF` を使用します。  
  
 `EOF` 関数は、ファイルの末尾に到達するまで `False` を返します。 `Random` または `Binary` アクセスのために開かれたファイルを使用すると `EOF`、最後に実行された `FileGet` 関数がレコード全体を読み取ることができなくなるまで、`False` が返されます。  
  
 `Binary` アクセスのために開かれたファイルでは、`EOF` が `True` 返されるまで、`Input` 関数を使用してファイルを読み取ろうとすると、エラーが生成されます。 `Input`でバイナリファイルを読み取る場合は `EOF` ではなく `LOF` および `Loc` 関数を使用するか、`Get` 関数を使用する場合は `EOF` を使用します。 `Output`用に開かれたファイルでは、`EOF` は常に `True`を返します。  
  
   
  
## Examples  
 この例では、`EOF` 関数を使用して、ファイルの終わりを検出します。 この例では、`Testfile` が複数行のテキストを含むテキストファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 [https://login.microsoftonline.com/consumers/](<see langword="Integer" />) 任意の有効なファイル数。</param>
        <summary><see langword="FileOpen" /> 関数を使用して開いたファイルのファイル モードを表す列挙体を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="FileAttr" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> 」を参照してください。</summary>
        <returns>次の列挙型値は、ファイルのアクセス モードを示します。 
 <list type="table"><item><term> 値 
 </term><description> モード 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この関数は、`FileOpen` 関数を使用して開かれたファイルのファイルモードを表す列挙体を返します。  
  
   
  
## Examples  
 この例では、`FileAttr` 関数を使用して、開いているファイルのファイルモードを返します。  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileClose(int32[] FileNumbers) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">省略可能。 閉じる対象となる、0 以上のチャネルで構成されるパラメーター配列。</param>
        <summary><see langword="FileOpen" /> 関数で開いたファイルへの入出力を終了して、ファイルを閉じます。 <see langword="My" /> を使用すると、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳細については、「[方法: StreamReader を使用してファイルからテキストを読み取る](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader)」、「[方法: StreamWriter を使用してファイルにテキストを書き込む](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter)」、「[チュートリアル: Visual Basic でのファイルとディレクトリの操作](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories)」を参照してください。  
  
 `FileNumbers`を省略した場合は、`FileOpen` 関数によって開かれたすべてのアクティブなファイルが閉じられます。  
  
 `Output` または `Append`用に開かれたファイルを閉じると、出力の最終的なバッファーがそのファイルのオペレーティングシステムバッファーに書き込まれます。 閉じたファイルに関連付けられているすべてのバッファー領域が解放されます。  
  
 `FileClose` 関数が実行されると、ファイルとファイル番号の関連付けが終了します。  
  
   
  
## Examples  
 この例では、`FileClose` 関数を使用して、`Input`用に開かれたファイルを閉じます。  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> は存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/statements/end-statement">End ステートメント</related>
        <related type="Article" href="/dotnet/visual-basic/language-reference/statements/stop-statement">Stop ステートメント (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileCopy(string Source, string Destination) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">必須。 コピーするファイルの名前を指定する文字列式です。 <paramref name="Source" /> には、コピー先ファイルのディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <param name="Destination">必須。 コピー先のファイルの名前を指定する文字列式です。 <paramref name="Destination" /> には、コピー先ファイルのディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイルをコピーします。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="FileCopy" /> を使用した場合よりも、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> 」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在開いているファイルで `FileCopy` 関数を使用しようとすると、エラーが発生します。  
  
 `FileCopy` ローカルドライブでの完全な信頼が必要です。  
  
   
  
## Examples  
 この例では、`FileCopy` 関数を使用して、あるファイルを別のファイルにコピーします。 この例では、`SrcFile` がデータを含むファイルであることを想定しています。  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Source" /> または <paramref name="Destination" /> が無効であるか、指定されていません。</exception>
        <exception cref="T:System.IO.IOException">ファイルは既に開いています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory">方法 : Visual Basic でファイルのコピーを別のディレクトリに作成する</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory">方法 : Visual Basic でファイルのコピーを同じディレクトリに作成する</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory">方法 : Visual Basic でディレクトリを別のディレクトリにコピーする</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FileDateTime(string PathName) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須。 ファイル名を指定する文字列式です。 <paramref name="PathName" /> には、ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイルへの書き込み日時を示す <see langword="Date" /> 値を返します。 <see langword="My" /> 機能を使用すると、 <see langword="FileDateTime" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> を参照してください。</summary>
        <returns>ファイルの作成日時または最終変更日時を示す <see langword="Date" /> 値を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では、`FileDateTime` 関数を使用して、ファイルが作成された日時または最後に変更された日時を確認します。 表示される日付と時刻の形式は、システムのロケール設定に基づいています。  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="PathName" /> が無効です。またはワイルドカードを含んでいます。</exception>
        <exception cref="T:System.IO.FileNotFoundException">対象のファイルが存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、 <see langword="FileGet" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、 <see langword="FileGet" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FileGet` で読み取られるデータは、通常、`FilePut`を持つファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合は、最後の `FileGet` または `FilePut` 関数の次のレコードまたはバイト (または最後の `Seek` 関数が指す) が読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   読み取られるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FileGet` は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列の場合、`FileGet` は文字列長を含む2バイト記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を使用せずに文字列を読み取る場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、`FileGet` に渡される配列のサイズと境界によって、読み取る内容が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト: (2 + 8 * 2)  
  
    -   データの200バイト: (5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、`FileGet` は変数データだけを読み取ります。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet` は、それぞれが個別に読み取られているかのように構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(`FilePut`で記述された) ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の記述子 (2 + 8 * NumberOfDimensions) がプレフィックスとして付けられます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FileGet` は、すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FileGet` はデータだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet` は、2バイト長の記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet` 関数を使用してファイルを読み取るには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Read` アクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、 <see langword="FileGet" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FileGet` で読み取られるデータは、通常、`FilePut`を持つファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合は、最後の `FileGet` または `FilePut` 関数の次のレコードまたはバイト (または最後の `Seek` 関数が指す) が読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   読み取られるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FileGet` は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列の場合、`FileGet` は文字列長を含む2バイト記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を使用せずに文字列を読み取る場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は。 次に、に渡される配列のサイズと境界を `FileGet` て、読み取る対象を決定します。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト: (2 + 8 * 2)  
  
    -   データの200バイト: (5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、`FileGet` は変数データだけを読み取ります。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet` は、それぞれが個別に読み取られているかのように構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(`FilePut`で記述された) ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の記述子 (2 + 8 * NumberOfDimensions) がプレフィックスとして付けられます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FileGet` は、すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FileGet` はデータだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet` は、2バイト長の記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet` 関数を使用してファイルを読み取るには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Read` アクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、 <see langword="FileGet" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FileGet` で読み取られるデータは、通常、`FilePut`を持つファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合は、最後の `FileGet` または `FilePut` 関数の次のレコードまたはバイト (または最後の `Seek` 関数が指す) が読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   読み取られるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FileGet` は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列の場合、`FileGet` は文字列長を含む2バイト記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を使用せずに文字列を読み取る場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、`FileGet` に渡される配列のサイズと境界によって、読み取る内容が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト: (2 + 8 * 2)  
  
    -   データの200バイト: (5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、`FileGet` は変数データだけを読み取ります。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet` は、それぞれが個別に読み取られているかのように構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(`FilePut`で記述された) ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の記述子 (2 + 8 * NumberOfDimensions) がプレフィックスとして付けられます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FileGet` は、すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FileGet` はデータだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet` は、2バイト長の記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet` 関数を使用してファイルを読み取るには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Read` アクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、 <see langword="FileGet" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FileGet` で読み取られるデータは、通常、`FilePut`を持つファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合は、最後の `FileGet` または `FilePut` 関数の次のレコードまたはバイト (または最後の `Seek` 関数が指す) が読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   読み取られるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FileGet` は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列の場合、`FileGet` は文字列長を含む2バイト記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を使用せずに文字列を読み取る場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、`FileGet` に渡される配列のサイズと境界によって、読み取る内容が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト: (2 + 8 * 2)  
  
    -   データの200バイト: (5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、`FileGet` は変数データだけを読み取ります。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet` は、それぞれが個別に読み取られているかのように構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(`FilePut`で記述された) ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の記述子 (2 + 8 * NumberOfDimensions) がプレフィックスとして付けられます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FileGet` は、すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FileGet` はデータだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet` は、2バイト長の記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet` 関数を使用してファイルを読み取るには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Read` アクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、 <see langword="FileGet" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FileGet` で読み取られるデータは通常、`FilePut`を使用してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合は、最後の `FileGet` または `FilePut` 関数の次のレコードまたはバイト (または最後の `Seek` 関数が指す) が読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   読み取られるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FileGet` は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列の場合、`FileGet` は文字列長を含む2バイト記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を使用せずに文字列を読み取る場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、`FileGet` に渡される配列のサイズと境界によって、読み取る内容が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト: (2 + 8 * 2)  
  
    -   データの200バイト: (5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、`FileGet` は変数データだけを読み取ります。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet` は、それぞれが個別に読み取られているかのように構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(`FilePut`で記述された) ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の記述子 (2 + 8 * NumberOfDimensions) がプレフィックスとして付けられます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FileGet` は、すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FileGet` はデータだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet` は、2バイト長の記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet` 関数を使用してファイルを読み取るには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Read` アクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、 <see langword="FileGet" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FileGet` で読み取られるデータは通常、`FilePut`を使用してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合は、最後の `FileGet` または `FilePut` 関数の次のレコードまたはバイト (または最後の `Seek` 関数が指す) が読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   読み取られるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FileGet` は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列の場合、`FileGet` は文字列長を含む2バイト記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を使用せずに文字列を読み取る場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、`FileGet` に渡される配列のサイズと境界によって、読み取る内容が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト: (2 + 8 * 2)  
  
    -   データの200バイト: (5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、`FileGet` は変数データだけを読み取ります。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet` は、それぞれが個別に読み取られているかのように構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(`FilePut`で記述された) ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の記述子 (2 + 8 * NumberOfDimensions) がプレフィックスとして付けられます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FileGet` は、すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FileGet` はデータだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet` は、2バイト長の記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet` 関数を使用してファイルを読み取るには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Read` アクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、 <see langword="FileGet" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FileGet` で読み取られるデータは通常、`FilePut`を使用してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合は、最後の `FileGet` または `FilePut` 関数の次のレコードまたはバイト (または最後の `Seek` 関数が指す) が読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   読み取られるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FileGet` は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列の場合、`FileGet` は文字列長を含む2バイト記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を使用せずに文字列を読み取る場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、`FileGet` に渡される配列のサイズと境界によって、読み取る内容が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト: (2 + 8 * 2)  
  
    -   データの200バイト: (5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、`FileGet` は変数データだけを読み取ります。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet` は、それぞれが個別に読み取られているかのように構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(`FilePut`で記述された) ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の記述子 (2 + 8 * NumberOfDimensions) がプレフィックスとして付けられます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FileGet` は、すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FileGet` はデータだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet` は、2バイト長の記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet` 関数を使用してファイルを読み取るには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Read` アクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、 <see langword="FileGet" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FileGet` で読み取られるデータは通常、`FilePut`を使用してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合は、最後の `FileGet` または `FilePut` 関数の次のレコードまたはバイト (または最後の `Seek` 関数が指す) が読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   読み取られるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FileGet` は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列の場合、`FileGet` は文字列長を含む2バイト記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を使用せずに文字列を読み取る場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、`FileGet` に渡される配列のサイズと境界によって、読み取る内容が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト: (2 + 8 * 2)  
  
    -   データの200バイト: (5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、`FileGet` は変数データだけを読み取ります。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet` は、それぞれが個別に読み取られているかのように構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(`FilePut`で記述された) ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の記述子 (2 + 8 * NumberOfDimensions) がプレフィックスとして付けられます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FileGet` は、すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FileGet` はデータだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet` は、2バイト長の記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet` 関数を使用してファイルを読み取るには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Read` アクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、 <see langword="FileGet" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FileGet` で読み取られるデータは通常、`FilePut`を使用してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合は、最後の `FileGet` または `FilePut` 関数の次のレコードまたはバイト (または最後の `Seek` 関数が指す) が読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   読み取られるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FileGet` は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列の場合、`FileGet` は文字列長を含む2バイト記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を使用せずに文字列を読み取る場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、`FileGet` に渡される配列のサイズと境界によって、読み取る内容が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト: (2 + 8 * 2)  
  
    -   データの200バイト: (5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、`FileGet` は変数データだけを読み取ります。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet` は、それぞれが個別に読み取られているかのように構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(`FilePut`で記述された) ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の記述子 (2 + 8 * NumberOfDimensions) がプレフィックスとして付けられます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FileGet` は、すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FileGet` はデータだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet` は、2バイト長の記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet` 関数を使用してファイルを読み取るには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Read` アクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、 <see langword="FileGet" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FileGet` で読み取られるデータは通常、`FilePut`を使用してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合は、最後の `FileGet` または `FilePut` 関数の次のレコードまたはバイト (または最後の `Seek` 関数が指す) が読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   読み取られるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FileGet` は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列の場合、`FileGet` は文字列長を含む2バイト記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を使用せずに文字列を読み取る場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、`FileGet` に渡される配列のサイズと境界によって、読み取る内容が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト: (2 + 8 * 2)  
  
    -   データの200バイト: (5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、`FileGet` は変数データだけを読み取ります。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet` は、それぞれが個別に読み取られているかのように構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(`FilePut`で記述された) ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の記述子 (2 + 8 * NumberOfDimensions) がプレフィックスとして付けられます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FileGet` は、すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FileGet` はデータだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet` は、2バイト長の記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet` 関数を使用してファイルを読み取るには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Read` アクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、 <see langword="FileGet" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FileGet` で読み取られるデータは通常、`FilePut`を使用してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合は、最後の `FileGet` または `FilePut` 関数の次のレコードまたはバイト (または最後の `Seek` 関数が指す) が読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   読み取られるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FileGet` は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列の場合、`FileGet` は文字列長を含む2バイト記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を使用せずに文字列を読み取る場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、`FileGet` に渡される配列のサイズと境界によって、読み取る内容が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト: (2 + 8 * 2)  
  
    -   データの200バイト: (5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、`FileGet` は変数データだけを読み取ります。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet` は、それぞれが個別に読み取られているかのように構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(`FilePut`で記述された) ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の記述子 (2 + 8 * NumberOfDimensions) がプレフィックスとして付けられます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FileGet` は、すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FileGet` はデータだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet` は、2バイト長の記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet` 関数を使用してファイルを読み取るには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Read` アクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <param name="StringIsFixedLength">省略可能。 文字列を書き込む場合のみ適用します。 長さを表す文字列に対して 2 バイトの記述子を書き込むかどうかを指定します。 既定では、 <see langword="False" />です。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、 <see langword="FileGet" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FileGet` で読み取られるデータは通常、`FilePut`を使用してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合は、最後の `FileGet` または `FilePut` 関数の次のレコードまたはバイト (または最後の `Seek` 関数が指す) が読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   読み取られるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FileGet` は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列の場合、`FileGet` は文字列長を含む2バイト記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を使用せずに文字列を読み取る場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、`FileGet` に渡される配列のサイズと境界によって、読み取る内容が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト: (2 + 8 * 2)  
  
    -   データの200バイト: (5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、`FileGet` は変数データだけを読み取ります。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet` は、それぞれが個別に読み取られているかのように構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(`FilePut`で記述された) ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の記述子 (2 + 8 * NumberOfDimensions) がプレフィックスとして付けられます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FileGet` は、すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FileGet` はデータだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet` は、2バイト長の記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet` 関数を使用してファイルを読み取るには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Read` アクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <param name="ArrayIsDynamic">省略可能。 文字列を書き込む場合のみ適用します。 配列を動的として扱うかどうか、およびサイズと境界を表す配列記述子が必要かどうかを指定します。</param>
        <param name="StringIsFixedLength">省略可能。 文字列を書き込む場合のみ適用します。 長さを表す文字列に対して 2 バイトの記述子を書き込むかどうかを指定します。 既定では、 <see langword="False" />です。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、 <see langword="FileGet" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FileGet` で読み取られるデータは通常、`FilePut`を使用してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合は、最後の `FileGet` または `FilePut` 関数の次のレコードまたはバイト (または最後の `Seek` 関数が指す) が読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   読み取られるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FileGet` は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列の場合、`FileGet` は文字列長を含む2バイト記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を使用せずに文字列を読み取る場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、`FileGet` に渡される配列のサイズと境界によって、読み取る内容が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト: (2 + 8 * 2)  
  
    -   データの200バイト: (5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、`FileGet` は変数データだけを読み取ります。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet` は、それぞれが個別に読み取られているかのように構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(`FilePut`で記述された) ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の記述子 (2 + 8 * NumberOfDimensions) がプレフィックスとして付けられます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FileGet` は、すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FileGet` はデータだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet` は、2バイト長の記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet` 関数を使用してファイルを読み取るには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Read` アクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">省略可能。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。  <see langword="My" /> 機能を使用すると、 <see langword="FileGetObject" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Integer`、`Long`、`Short`などの別の型ではなく型 `Object` が返される場合、コンパイル時のあいまいさを避けるために、`FileGet` の代わりに `FileGetObject` 関数が使用されます。  
  
 `Variant` 型を書き出す場合は、`FileGetObject` が必要です。 2番目のパラメーターにオブジェクトを使用している場合は、常に `FilePutObject` と `FileGetObject`を使用することをお勧めします。  
  
 `FileGetObject` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FileGetObject` で読み取られるデータは、通常、`FilePutObject`を使用して書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、`FileGetObject` は最後の `FileGetObject` または `FilePutObject` 関数の後 (または最後の `Seek` 関数によってポイントされた) の後にレコードまたはバイトを読み取ります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   読み取られるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FileGetObject` は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は正確には特定できないため、レコードの長さは、読み取るデータの長さと一致させることをお勧めします。  
  
-   に読み取る変数が文字列の場合、既定では `FileGetObject` は文字列長を含む2バイト記述子を読み取り、次に変数に入力されたデータを読み取ります。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長の文字列がサポートされており、ファイルに読み取るときに長さ記述子は書き込まれません。 記述子を使用せずに文字列を読み取る場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合、`FileOpen` 関数の `RecordLength` パラメーターで指定されるレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 8 ×次元の数になります (2 + 8 * NumberOfDimensions)。  
  
     たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要になります。  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     218バイトは次のように分散されます。記述子の場合は18バイト (2 + 8 * 2)、データの場合は100バイト (5 * 10 * 4)。  
  
-   `FileGetObject` は、それぞれが個別に読み取られているかのように構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(`FilePutObject`を使用して記述された) ユーザー定義型の動的配列には、長さが 2 + 次元数が8倍である記述子 (2 + 8 * NumberOfDimensions) がプレフィックスとして付けられます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列とその記述子を含む、個々の要素の読み取りに必要なすべてのバイトの合計以上である必要があります。 <xref:Microsoft.VisualBasic.VBFixedStringAttribute> クラスは、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合、`Random` のすべての規則が適用されます。ただし、次のような例外があります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FileGetObject` は、ディスクからすべての変数を連続的に読み取ります。つまり、レコード間に埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FileGetObject` はデータだけを読み取ります。 記述子が読み取られません。  
  
 `FileGetObject` は、2バイト長の記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
   
  
## Examples  
 次の例では、レコードをテストファイルに読み込んで取得します。  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 FileLen(string PathName) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須。 ファイルを指定する文字列式です。 <paramref name="PathName" /> には、ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイルの長さをバイト数で指定する値を返します。 <see langword="My" /> 機能を使用すると、 <see langword="FileLen" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> を参照してください。</summary>
        <returns>バイト単位のファイルの長さです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileLen` 関数が呼び出されたときに、指定したファイルが開いている場合、返される値は、ファイルが開かれたときのファイルのサイズを表します。  
  
> [!NOTE]
>  開いているファイルの現在の長さを取得するには、`LOF` 関数を使用します。  
  
   
  
## Examples  
 この例では、`FileLen` 関数を使用して、ファイルの長さをバイト単位で返します。 この例では、`TestFile` がデータを含むファイルであることを想定しています。  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。 <see langword="FreeFile" /> 関数を使用して、次に使用できるファイル番号を取得します。</param>
        <param name="FileName">必須。 ファイル名を指定する文字列式。ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <param name="Mode">必須。 ファイル モード (<see langword="Append" />、<see langword="Binary" />、<see langword="Input" />、<see langword="Output" />、または <see langword="Random" />) を指定する列挙体。 詳細については、「<see cref="T:Microsoft.VisualBasic.OpenMode" />」を参照してください。</param>
        <param name="Access">省略可能。 開いているファイルで許可されている操作 (<see langword="Read" />、<see langword="Write" />、または <see langword="ReadWrite" />) を示す列挙体。 既定値は <see langword="ReadWrite" /> です。 詳細については、「<see cref="T:Microsoft.VisualBasic.OpenAccess" />」を参照してください。</param>
        <param name="Share">省略可能。 他のプロセスによって開かれたファイルで許可されていない操作 (<see langword="Shared" />、<see langword="Lock Read" />、<see langword="Lock Write" />、および <see langword="Lock Read Write" />) を指定する列挙体。 既定値は <see langword="Lock Read Write" /> です。 詳細については、「<see cref="T:Microsoft.VisualBasic.OpenShare" />」を参照してください。</param>
        <param name="RecordLength">省略可能。 32,767 以下の値 (バイト単位)。 ランダム アクセス ファイルの場合は、レコード長を表します。 シーケンシャル ファイルの場合は、バッファー内の文字数を表します。</param>
        <summary>ファイルを開いて入出力を行います。 <see langword="My" /> 機能を使用すると、 <see langword="FileOpen" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 I/o 操作を実行する前に、ファイルを開く必要があります。 `FileOpen` は、i/o 用のバッファーをファイルに割り当て、バッファーで使用するアクセスモードを決定します。  
  
> [!IMPORTANT]
>  ファイルに書き込むときに、書き込み先のファイルが存在しない場合、アプリケーションでファイルを作成する必要がある場合があります。 これを行うには、ファイルを作成するディレクトリに対するアクセス許可が必要です。 ただし、`FileName` によって指定されたファイルが存在する場合、アプリケーションはファイル自体に対してのみ `Write` アクセス許可を必要とします。 可能な限り、セキュリティを強化するために、展開中にファイルを作成し、そのファイルに対する `Write` アクセス許可を付与します (ディレクトリ全体ではなく)。 セキュリティを強化するために、ルートディレクトリや Program Files ディレクトリではなく、ユーザーディレクトリにデータを書き込みます。  
  
 開くチャネルは、`FreeFile()` 関数を使用して見つけることができます。  
  
> [!IMPORTANT]
>  `FileOpen` 関数は `FileIOPermissionAccess` 列挙からアクセス `Read` 必要があります。これは、部分信頼状況での実行に影響を与える可能性があります。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙型」を参照してください。  
  
   
  
## Examples  
 この例では、ファイルへの入力と出力を可能にするための `FileOpen` 関数のさまざまな使用方法を示します。  
  
 次のコードでは、ファイル `TestFile` を `Input` モードで開きます。  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 この例では、書き込み操作のみを `Binary` モードでファイルを開きます。  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 次の例では、`Random` モードでファイルを開きます。 このファイルには `Person`構造体のレコードが含まれています。  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 このコード例では、`Output` モードでファイルを開きます。すべてのプロセスでファイルの読み取りまたは書き込みを行うことができます。  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 このコード例では、読み取り用に `Binary` モードでファイルを開きます。他のプロセスがファイルを読み取ることができません。  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">レコード長が、-1 ではない負の値です。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileName" /> が既に開かれています。または <paramref name="FileName" /> が無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、 `FileGet`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、最後の `FileGet` または `FilePut` 関数の後、または最後の `Seek` 関数によってポイントされた次のレコードまたはバイトが書き込まれます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePut` は長さ記述子を書き込みません。 `FilePut`で `StringIsFixedLength` = `True` を使用する場合は、`FileGet`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FilePut` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が文字列の場合、`FilePut` は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePut` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である場合、`FilePut` は変数データだけを書き込みます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut` は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString` 属性によって指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePut` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FilePut` はデータだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` は、2バイト長記述子のない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut` 関数を使用してファイルに書き込むには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Write` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`FilePut` 関数を使用して、データをファイルに書き込みます。 構造 `Person` の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、 `FileGet`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、最後の `FileGet` または `FilePut` 関数の後、または最後の `Seek` 関数によってポイントされた次のレコードまたはバイトが書き込まれます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePut` は長さ記述子を書き込みません。 `FilePut`で `StringIsFixedLength` = `True` を使用する場合は、`FileGet`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FilePut` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が文字列の場合、`FilePut` は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePut` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である場合、`FilePut` は変数データだけを書き込みます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut` は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString` 属性によって指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePut` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FilePut` はデータだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` は、2バイト長記述子のない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut` 関数を使用してファイルに書き込むには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Write` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`FilePut` 関数を使用して、データをファイルに書き込みます。 構造 `Person` の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、 `FileGet`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、最後の `FileGet` または `FilePut` 関数の後、または最後の `Seek` 関数によってポイントされた次のレコードまたはバイトが書き込まれます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePut` は長さ記述子を書き込みません。 `FilePut`で `StringIsFixedLength` = `True` を使用する場合は、`FileGet`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FilePut` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が文字列の場合、`FilePut` は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePut` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である場合、`FilePut` は変数データだけを書き込みます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut` は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString` 属性によって指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePut` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FilePut` はデータだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` は、2バイト長記述子のない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut` 関数を使用してファイルに書き込むには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Write` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`FilePut` 関数を使用して、データをファイルに書き込みます。 構造 `Person` の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、 `FileGet`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、最後の `FileGet` または `FilePut` 関数の後、または最後の `Seek` 関数によってポイントされた次のレコードまたはバイトが書き込まれます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePut` は長さ記述子を書き込みません。 `FilePut`で `StringIsFixedLength` = `True` を使用する場合は、`FileGet`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FilePut` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が文字列の場合、`FilePut` は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePut` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である場合、`FilePut` は変数データだけを書き込みます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut` は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString` 属性によって指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePut` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FilePut` はデータだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` は、2バイト長記述子のない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut` 関数を使用してファイルに書き込むには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Write` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`FilePut` 関数を使用して、データをファイルに書き込みます。 構造 `Person` の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、 `FileGet`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、最後の `FileGet` または `FilePut` 関数の後、または最後の `Seek` 関数によってポイントされた次のレコードまたはバイトが書き込まれます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePut` は長さ記述子を書き込みません。 `FilePut`で `StringIsFixedLength` = `True` を使用する場合は、`FileGet`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FilePut` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が文字列の場合、`FilePut` は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePut` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である場合、`FilePut` は変数データだけを書き込みます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut` は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString` 属性によって指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePut` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FilePut` はデータだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` は、2バイト長記述子のない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut` 関数を使用してファイルに書き込むには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Write` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`FilePut` 関数を使用して、データをファイルに書き込みます。 構造 `Person` の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、 `FileGet`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、最後の `FileGet` または `FilePut` 関数の後、または最後の `Seek` 関数によってポイントされた次のレコードまたはバイトが書き込まれます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePut` は長さ記述子を書き込みません。 `FilePut`で `StringIsFixedLength` = `True` を使用する場合は、`FileGet`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FilePut` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が文字列の場合、`FilePut` は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePut` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である場合、`FilePut` は変数データだけを書き込みます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut` は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString` 属性によって指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePut` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FilePut` はデータだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` は、2バイト長記述子のない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut` 関数を使用してファイルに書き込むには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Write` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`FilePut` 関数を使用して、データをファイルに書き込みます。 構造 `Person` の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、 `FileGet`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、最後の `FileGet` または `FilePut` 関数の後、または最後の `Seek` 関数によってポイントされた次のレコードまたはバイトが書き込まれます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePut` は長さ記述子を書き込みません。 `FilePut`で `StringIsFixedLength` = `True` を使用する場合は、`FileGet`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FilePut` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が文字列の場合、`FilePut` は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePut` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePut` は、オブジェクトの`VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である場合、`FilePut` は変数データだけを書き込みます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut` は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString` 属性によって指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePut` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FilePut` はデータだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` は、2バイト長記述子のない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut` 関数を使用してファイルに書き込むには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Write` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`FilePut` 関数を使用して、データをファイルに書き込みます。 構造 `Person` の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、 `FileGet`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、最後の `FileGet` または `FilePut` 関数の後、または最後の `Seek` 関数によってポイントされた次のレコードまたはバイトが書き込まれます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePut` は長さ記述子を書き込みません。 `FilePut`で `StringIsFixedLength` = `True` を使用する場合は、`FileGet`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FilePut` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が文字列の場合、`FilePut` は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePut` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である場合、`FilePut` は変数データだけを書き込みます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut` は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString` 属性によって指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePut` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FilePut` はデータだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` は、2バイト長記述子のない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut` 関数を使用してファイルに書き込むには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Write` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`FilePut` 関数を使用して、データをファイルに書き込みます。 構造 `Person` の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、 `FileGet`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、最後の `FileGet` または `FilePut` 関数の後、または最後の `Seek` 関数によってポイントされた次のレコードまたはバイトが書き込まれます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePut` は長さ記述子を書き込みません。 `FilePut`で `StringIsFixedLength` = `True` を使用する場合は、`FileGet`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FilePut` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が文字列の場合、`FilePut` は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePut` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である場合、`FilePut` は変数データだけを書き込みます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut` は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString` 属性によって指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePut` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FilePut` はデータだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` は、2バイト長記述子のない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut` 関数を使用してファイルに書き込むには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Write` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`FilePut` 関数を使用して、データをファイルに書き込みます。 構造 `Person` の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、 `FileGet`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、最後の `FileGet` または `FilePut` 関数の後、または最後の `Seek` 関数によってポイントされた次のレコードまたはバイトが書き込まれます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePut` は長さ記述子を書き込みません。 `FilePut`で `StringIsFixedLength` = `True` を使用する場合は、`FileGet`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FilePut` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が文字列の場合、`FilePut` は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePut` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である場合、`FilePut` は変数データだけを書き込みます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut` は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString` 属性によって指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePut` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FilePut` はデータだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` は、2バイト長記述子のない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut` 関数を使用してファイルに書き込むには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Write` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`FilePut` 関数を使用して、データをファイルに書き込みます。 構造 `Person` の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、 `FileGet`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、最後の `FileGet` または `FilePut` 関数の後、または最後の `Seek` 関数によってポイントされた次のレコードまたはバイトが書き込まれます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePut` は長さ記述子を書き込みません。 `FilePut`で `StringIsFixedLength` = `True` を使用する場合は、`FileGet`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の`RecordLength` 句で指定された長さよりも少ない場合、`FilePut` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が文字列の場合、`FilePut` は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePut` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である場合、`FilePut` は変数データだけを書き込みます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut` は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString` 属性によって指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePut` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FilePut` はデータだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` は、2バイト長記述子のない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut` 関数を使用してファイルに書き込むには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Write` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`FilePut` 関数を使用して、データをファイルに書き込みます。 構造 `Person` の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, RecordNumber As Object)" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FilePut(System::Object ^ FileNumber, System::Object ^ Value, System::Object ^ RecordNumber);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、 `FileGet`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、最後の `FileGet` または `FilePut` 関数の後、または最後の `Seek` 関数によってポイントされた次のレコードまたはバイトが書き込まれます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePut` は長さ記述子を書き込みません。 `FilePut`で `StringIsFixedLength` = `True` を使用する場合は、`FileGet`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FilePut` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が文字列の場合、`FilePut` は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePut` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である場合、`FilePut` は変数データだけを書き込みます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut` は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString` 属性によって指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePut` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FilePut` はデータだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` は、2バイト長記述子のない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut` 関数を使用してファイルに書き込むには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Write` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`FilePut` 関数を使用して、データをファイルに書き込みます。 構造 `Person` の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <param name="StringIsFixedLength">省略可能。 文字列を書き込む場合のみ適用します。 長さを表す文字列に対して 2 バイトの記述子を書き込むかどうかを指定します。 既定では、 <see langword="False" />です。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、 `FileGet`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、最後の `FileGet` または `FilePut` 関数の後、または最後の `Seek` 関数によってポイントされた次のレコードまたはバイトが書き込まれます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePut` は長さ記述子を書き込みません。 `FilePut`で `StringIsFixedLength` = `True` を使用する場合は、`FileGet`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FilePut` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が文字列の場合、`FilePut` は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePut` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である場合、`FilePut` は変数データだけを書き込みます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut` は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString` 属性によって指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePut` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FilePut` はデータだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` は、2バイト長記述子のない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut` 関数を使用してファイルに書き込むには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Write` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`FilePut` 関数を使用して、データをファイルに書き込みます。 構造 `Person` の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <param name="ArrayIsDynamic">省略可能。 文字列を書き込む場合のみ適用します。 配列を動的として扱うかどうか、および長さを表す文字列の配列記述子を書き込むかどうかを指定します。</param>
        <param name="StringIsFixedLength">省略可能。 文字列を書き込む場合のみ適用します。 長さを表す文字列に対して 2 バイトの記述子を書き込むかどうかを指定します。 既定では、 <see langword="False" />です。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、 <see langword="FilePut" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、 `FileGet`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、最後の `FileGet` または `FilePut` 関数の後、または最後の `Seek` 関数によってポイントされた次のレコードまたはバイトが書き込まれます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePut` は長さ記述子を書き込みません。 `FilePut`で `StringIsFixedLength` = `True` を使用する場合は、`FileGet`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FilePut` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が文字列の場合、`FilePut` は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、`FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePut` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePut` は、オブジェクトの `VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、`ArrayIsDynamic` パラメーターを `True`に設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である場合、`FilePut` は変数データだけを書き込みます。 `FileOpen` 関数の `RecordLength` 句によって指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut` は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 `VBFixedString` 属性は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString` 属性によって指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルの場合は、ほとんどの `Random` モードの規則が適用されますが、例外もあります。 `Binary` モードで開かれたファイルの次の規則は、`Random` モードの規則とは異なります。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePut` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、`FilePut` はデータだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` は、2バイト長記述子のない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut` 関数を使用してファイルに書き込むには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Write` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`FilePut` 関数を使用して、データをファイルに書き込みます。 構造 `Person` の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">省略可能。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。  <see langword="My" /> 機能を使用すると、 <see langword="FilePutObject" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePutObject` 関数は、`Integer`、`Long`、`Short`などの別の型ではなく型 `Object` が渡される場合に、コンパイル時のあいまいさを避けるために、`FilePut` の代わりに使用されます。  
  
 `FilePutObject` は、オブジェクトを記述する記述子を書き込み、読み取ります。 `Variant` 型を書き出す場合は、`FilePutObject` が必要です。 2番目のパラメーターとしてオブジェクトを使用している場合は、常に `FilePutObject` と `FileGetObject`を使用することをお勧めします。  
  
 `FilePutObject` は `Random` モードと `Binary` モードでのみ有効です。  
  
 `FilePutObject` を使用して書き込まれたデータは通常、 `FileGetObject`を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した場合、`FilePutObject` は最後の `FileGetObject` または `FilePutObject` 関数の後に次のレコードまたはバイト (または最後の `Seek` 関数によって示されるレコードまたはバイト) を書き込みます。  
  
 `StringIsFixedLength` 引数は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 引数が `True`場合、`FilePutObject` は長さ記述子を書き込みません。 `FilePutObject`で `StringIsFixedLength` = `True` を使用する場合は、`FileGetObject`で同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムモード  
 `Random` モードで開かれたファイルについては、次の規則が適用されます。  
  
-   書き込まれるデータの長さが、`FileOpen` 関数の `RecordLength` 句で指定された長さよりも少ない場合、`FilePutObject` は、後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は正確には特定できないため、通常は、レコードの長さを、書き込まれるデータの長さと一致させることをお勧めします。 書き込まれているデータの長さが、`FileOpen` 関数の `RecordLength` 句に指定された長さよりも大きい場合、例外がスローされます。  
  
-   書き込まれている変数が数値型を含むオブジェクトの場合、`FilePutObject` は、オブジェクトの `VarType` を識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、`FilePutObject` は6バイトを書き込みます。これは、オブジェクトを `VarType(3)` (`Integer`) として識別する2バイトと、データを格納する4バイトです。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、`FilePutObject` は、オブジェクトの `VarType(8)` を識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen` 関数の `RecordLength` パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、`True` を `StringIsFixedLength` パラメーターに渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込む変数が配列の場合、`FileOpen` 関数の `RecordLength` 句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります (2 + 8 * NumberOfDimensions)。  
  
## <a name="binary-mode"></a>バイナリモード  
 `Binary` モードで開かれたファイルについては、次の場合を除き、すべての `Random` モードの規則が適用されます。  
  
-   `FileOpen` 関数の `RecordLength` 句には効果がありません。 `FilePutObject` は、すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
   
  
## Examples  
 この例では、`FilePutObject` 関数を使用して、ファイルに文字列を書き込みます。  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="RecordWidth">必須。 改行される前に 1 行に表示できる文字数を表す 0 から 255 の範囲の数式。 <paramref name="RecordWidth" /> が 0 の場合は、行の長さに制限がないことを示します。 <paramref name="RecordWidth" /> の既定値は 0 です。</param>
        <summary><see langword="FileOpen" /> 関数を使用して開いたファイルに出力行の桁数を割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では、`FileWidth` 関数を使用して、ファイルの出力線の幅を設定します。  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FreeFile() cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="Integer" /> 関数で使用できる次のファイル番号を表す <see langword="FileOpen" /> 値を返します。</summary>
        <returns><see langword="FileOpen" /> 関数で使用できる次のファイル番号を表す整数値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FreeFile` を使用して、まだ使用されていないファイル番号を指定します。  
  
   
  
## Examples  
 この例では、`FreeFile` 関数を使用して、次に使用可能なファイル番号を返します。 ループ内の出力用に5つのファイルが開かれ、いくつかのサンプルデータがそれぞれに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">使用中のファイルが 255 個を超えています。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須。 ファイル、ディレクトリ、またはフォルダーの名前を指定する文字列式です。 <paramref name="PathName" /> には、ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイル、ディレクトリ、またはフォルダーの属性を表す <see langword="FileAttribute" /> 型の値を返します。 <see langword="My" /> 機能を使用すると、 <see langword="FileAttribute" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <returns>列挙値のビットごとの組み合わせ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 どの属性が設定されているかを判断するには、`And` 演算子を使用して、`GetAttr` 関数によって返される値と、必要な個々のファイル属性の値のビットごとの比較を実行します。 結果が0でない場合は、その属性が名前付きファイルに対して設定されます。 たとえば、次の `And` 式の戻り値は、`Archive` 属性が設定されていない場合は0になります。  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 `Archive` の属性が設定されている場合は、0以外の値が返されます。  
  
   
  
## Examples  
 この例では、`GetAttr` 関数を使用して、ファイル、ディレクトリ、またはフォルダーの属性を決定します。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="Pathname" /> が無効です。またはワイルドカードを含んでいます。</exception>
        <exception cref="T:System.IO.FileNotFoundException">対象のファイルが存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/operators/and-operator">And 演算子 (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, bool&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Input` で読み取られるデータは通常、`Write`を使用してファイルに書き込まれます。 この関数は、`Input` モードまたは `Binary` モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|Data|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR `errornumber`#|`errornumber` (変数はエラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input` 関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input` 関数を使用してファイルを読み取るには、`FileIOPermissionAccess` 列挙からの `Read` アクセスが必要です。 詳細については、<xref:System.Security.Permissions.FileIOPermissionAccess> を参照してください。  
  
   
  
## Examples  
 この例では、`Input` 関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では、`TestFile` が、`Write` 関数を使用してデータ行に書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello", 234) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * byte -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Input` で読み取られるデータは通常、`Write`を使用してファイルに書き込まれます。 この関数は、`Input` モードまたは `Binary` モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|Data|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR `errornumber`#|`errornumber` (変数はエラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input` 関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input` 関数を使用してファイルを読み取るには、`FileIOPermissionAccess` 列挙からの `Read` アクセスが必要です。 詳細については、<xref:System.Security.Permissions.FileIOPermissionAccess> を参照してください。  
  
   
  
## Examples  
 この例では、`Input` 関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では、`TestFile` が、`Write` 関数を使用してデータ行に書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello", 234) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, char&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Input` で読み取られるデータは通常、`Write`を使用してファイルに書き込まれます。 この関数は、`Input` モードまたは `Binary` モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|Data|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR `errornumber`#|`errornumber` (変数はエラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input` 関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input` 関数を使用してファイルを読み取るには、`FileIOPermissionAccess` 列挙からの `Read` アクセスが必要です。 詳細については、<xref:System.Security.Permissions.FileIOPermissionAccess> を参照してください。  
  
   
  
## Examples  
 この例では、`Input` 関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では、`TestFile` が、`Write` 関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * DateTime -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Input` で読み取られるデータは通常、`Write`を使用してファイルに書き込まれます。 この関数は、`Input` モードまたは `Binary` モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|Data|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR `errornumber`#|`errornumber` (変数はエラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input` 関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input` 関数を使用してファイルを読み取るには、`FileIOPermissionAccess` 列挙からの `Read` アクセスが必要です。 詳細については、<xref:System.Security.Permissions.FileIOPermissionAccess> を参照してください。  
  
   
  
## Examples  
 この例では、`Input` 関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では、`TestFile` が、`Write` 関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * decimal -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Input` で読み取られるデータは通常、`Write`を使用してファイルに書き込まれます。 この関数は、`Input` モードまたは `Binary` モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|Data|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR `errornumber`#|`errornumber` (変数はエラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input` 関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input` 関数を使用してファイルを読み取るには、`FileIOPermissionAccess` 列挙からの `Read` アクセスが必要です。 詳細については、<xref:System.Security.Permissions.FileIOPermissionAccess> を参照してください。  
  
   
  
## Examples  
 この例では、`Input` 関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では、`TestFile` が、`Write` 関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, float64&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * double -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Input` で読み取られるデータは通常、`Write`を使用してファイルに書き込まれます。 この関数は、`Input` モードまたは `Binary` モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|Data|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR `errornumber`#|`errornumber` (変数はエラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input` 関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input` 関数を使用してファイルを読み取るには、`FileIOPermissionAccess` 列挙からの `Read` アクセスが必要です。 詳細については、<xref:System.Security.Permissions.FileIOPermissionAccess> を参照してください。  
  
   
  
## Examples  
 この例では、`Input` 関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では、`TestFile` が、`Write` 関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, int16&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * int16 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Input` で読み取られるデータは通常、`Write`を使用してファイルに書き込まれます。 この関数は、`Input` モードまたは `Binary` モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|Data|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR `errornumber`#|`errornumber` (変数はエラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input` 関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input` 関数を使用してファイルを読み取るには、`FileIOPermissionAccess` 列挙からの `Read` アクセスが必要です。 詳細については、<xref:System.Security.Permissions.FileIOPermissionAccess> を参照してください。  
  
   
  
## Examples  
 この例では、`Input` 関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では、`TestFile` が、`Write` 関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, int32&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Input` で読み取られるデータは通常、`Write`を使用してファイルに書き込まれます。 この関数は、`Input` モードまたは `Binary` モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|Data|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR `errornumber`#|`errornumber` (変数はエラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input` 関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input` 関数を使用してファイルを読み取るには、`FileIOPermissionAccess` 列挙からの `Read` アクセスが必要です。 詳細については、<xref:System.Security.Permissions.FileIOPermissionAccess> を参照してください。  
  
   
  
## Examples  
 この例では、`Input` 関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では、`TestFile` が、`Write` 関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, int64&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Input` で読み取られるデータは通常、`Write`を使用してファイルに書き込まれます。 この関数は、`Input` モードまたは `Binary` モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|Data|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR `errornumber`#|`errornumber` (変数はエラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input` 関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input` 関数を使用してファイルを読み取るには、`FileIOPermissionAccess` 列挙からの `Read` アクセスが必要です。 詳細については、<xref:System.Security.Permissions.FileIOPermissionAccess> を参照してください。  
  
   
  
## Examples  
 この例では、`Input` 関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では、`TestFile` が、`Write` 関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, object&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Input` で読み取られるデータは通常、`Write`を使用してファイルに書き込まれます。 この関数は、`Input` モードまたは `Binary` モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|Data|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR `errornumber`#|`errornumber` (変数はエラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input` 関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input` 関数を使用してファイルを読み取るには、`FileIOPermissionAccess` 列挙からの `Read` アクセスが必要です。 詳細については、<xref:System.Security.Permissions.FileIOPermissionAccess> を参照してください。  
  
   
  
## Examples  
 この例では、`Input` 関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では、`TestFile` が、`Write` 関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, float32&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * single -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Input` で読み取られるデータは通常、`Write`を使用してファイルに書き込まれます。 この関数は、`Input` モードまたは `Binary` モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|Data|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR `errornumber`#|`errornumber` (変数はエラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input` 関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input` 関数を使用してファイルを読み取るには、`FileIOPermissionAccess` 列挙からの `Read` アクセスが必要です。 詳細については、<xref:System.Security.Permissions.FileIOPermissionAccess> を参照してください。  
  
   
  
## Examples  
 この例では、`Input` 関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では、`TestFile` が、`Write` 関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, string&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Input` で読み取られるデータは通常、`Write`を使用してファイルに書き込まれます。 この関数は、`Input` モードまたは `Binary` モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|Data|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR `errornumber`#|`errornumber` (変数はエラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input` 関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input` 関数を使用してファイルを読み取るには、`FileIOPermissionAccess` 列挙からの `Read` アクセスが必要です。 詳細については、<xref:System.Security.Permissions.FileIOPermissionAccess> を参照してください。  
  
   
  
## Examples  
 この例では、`Input` 関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では、`TestFile` が、`Write` 関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string InputString(int32 FileNumber, int32 CharCount) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="CharCount">必須。 読み込む文字数を指定する有効な任意の数式。</param>
        <summary><see langword="String" /> モードまたは <see langword="Input" /> モードで開いたファイルから読み取る文字を表す文字列型 (<see langword="Binary" />) の値を返します。 <see langword="My" /> 機能を使用すると、 <see langword="InputString" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <returns><see langword="Input" /> モードまたは <see langword="Binary" /> モードで開いたファイルからの文字が格納された文字列です。 <see langword="My" /> 機能を使用すると、 <see langword="InputString" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `InputString` 関数で読み取られるデータは通常、`Print` または `FilePut`を使用してファイルに書き込まれます。 この関数は、`Input` モードまたは `Binary` モードで開かれたファイルでのみ使用してください。  
  
 `Input` 関数とは異なり、`InputString` 関数は読み取るすべての文字を返します。 これには、コンマ、キャリッジリターン、ラインフィード、引用符、および先頭のスペースが含まれます。  
  
 `Binary` アクセスのために開かれたファイルを使用すると、`True` `EOF` によってエラーが生成されるまで、`InputString` 関数を使用してファイルを読み取ることができます。 `InputString`を使用してバイナリファイルを読み取るときに `EOF` ではなく `LOF` および `Loc` 関数を使用するか、`FileGet` 関数を使用するときに `EOF` を使用します。  
  
> [!NOTE]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいて、ファイルの内容に関するセキュリティ上の決定を行うことは避けてください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
   
  
## Examples  
 この例では、`InputString` 関数を使用して、ファイルから一度に1つの文字を読み取り、`Output` ウィンドウに出力します。 この例では、`MyFile` が複数行のサンプルデータを含むテキストファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> は存在しません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="CharCount" /> は &lt; 0 または &gt; 214 です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Kill(string PathName) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須。 削除する 1 つ以上のファイル名を指定する文字列式です。 <paramref name="PathName" /> には、ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイルをディスクから削除します。 <see langword="My" /> 機能を使用すると、 <see langword="Kill" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` では、複数文字 (`*`) と1文字 (`?`) のワイルドカードを使用して複数のファイルを指定できます。  
  
 **セキュリティ**に関する注意を実行するには、`Kill` 関数で、実行中のコードに <xref:System.Security.Permissions.FileIOPermission> のフラグ `Read` と `PathDiscovery` を与える必要があります。 詳細については、「<xref:System.Security.SecurityException>[コードアクセス許可](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)」を参照してください。  
  
   
  
## Examples  
 この例では、`Kill` 関数を使用して、ディスクからファイルを削除します。  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">対象のファイルが開かれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">対象のファイルが見つかりません。</exception>
        <exception cref="T:System.Security.SecurityException">アクセス許可は拒否されました。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LineInput(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <summary>開かれたシーケンシャル ファイルから 1 行を読み込み、<see langword="String" /> 変数に割り当てます。</summary>
        <returns>開かれたシーケンシャル ファイルから 1 行を読み込み、<see langword="String" /> 変数に割り当てます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `LineInput` で読み取られるデータは通常、`Print`を使用してファイルに書き込まれます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
 `LineInput` 関数は、キャリッジリターン (`Chr(13)`) またはキャリッジリターン/ラインフィード (`Chr(13) + Chr(10)`) シーケンスが検出されるまで、一度に1文字ずつファイルを読み取ります。 キャリッジリターン/ラインフィードシーケンスは、文字列に追加されるのではなく、スキップされます。  
  
> [!IMPORTANT]
>  `LineInput` 関数を使用してファイルを読み取るには、<xref:System.Security.Permissions.FileIOPermissionAccess> 列挙からの `Read` アクセスが必要です。  
  
   
  
## Examples  
 この例では、`LineInput` 関数を使用して、シーケンシャルファイルから行を読み取り、それを変数に代入します。 この例では、`TestFile` が複数行のサンプルデータを含むテキストファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">ファイルの終端に達しました。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> は存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Loc(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 有効な任意の <see langword="Integer" /> 型のファイル番号。</param>
        <summary>開かれたファイル内の現在の読み込みと書き込みの位置を指定する値を返します。</summary>
        <returns>開かれたファイル内の現在の読み取り/書き込み位置です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc` 関数は0から始まります。これを使用してファイル内の最初のバイトを取得すると、0が返されます。  
  
 `Loc` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 次に、各ファイルアクセスモードの戻り値について説明します。  
  
|モード|戻り値|  
|-|-|  
|`Random`|ファイルから読み取られた、またはファイルに書き込まれた最後のレコードの番号。|  
|`Sequential`|ファイル内の現在のバイト位置を128で割った値。 ただし、シーケンシャルファイルの `Loc` によって返される情報は、使用も必須でもありません。|  
|`Binary`|読み取りまたは書き込みが最後に読み取られたバイトの位置。|  
  
   
  
## Examples  
 この例では、`Loc` 関数を使用して、開いているファイル内の現在の読み取り/書き込み位置を返します。 この例では、`MyFile` が複数行のサンプルデータを含むテキストファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lock(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` および `Unlock` 関数は、複数のプロセスが同じファイルへのアクセスを必要とする環境で使用されます。  
  
 `Lock` 関数と `Unlock` 関数は、常にペアで使用されます。 `Lock` と `Unlock` の引数は、同一である必要があります。  
  
 `Record`、または `FromRecord` と `ToRecord` が指定されていない場合、ファイル全体に対してロックが設定されます。 `Record` だけを指定した場合は、1つのレコードがロックまたはロック解除されます。  
  
 ファイルがシーケンシャル入力または出力用に開かれている場合、`FromRecord` と`ToRecord`で指定された範囲に関係なく、`Lock` と `Unlock` はファイル全体に影響します。  
  
   
  
## Examples  
 この例では、`Lock` 関数と `Unlock` 関数の使用方法を示します。 この例では、`People.txt` が `Person`構造のレコードを含むファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lock(int32 FileNumber, int64 Record) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Record">省略可能。 ロックまたはアンロックされる唯一のレコードまたはバイトの番号。</param>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` および `Unlock` 関数は、複数のプロセスが同じファイルへのアクセスを必要とする環境で使用されます。  
  
 `Lock` 関数と `Unlock` 関数は、常にペアで使用されます。 `Lock` と `Unlock` の引数は、同一である必要があります。  
  
 `Record`、または `FromRecord` と `ToRecord` が指定されていない場合、ファイル全体に対してロックが設定されます。 `Record` だけを指定した場合は、1つのレコードがロックまたはロック解除されます。  
  
 ファイルがシーケンシャル入力または出力用に開かれている場合、`FromRecord` と`ToRecord`で指定された範囲に関係なく、`Lock` と `Unlock` はファイル全体に影響します。  
  
   
  
## Examples  
 この例では、`Lock` 関数と `Unlock` 関数の使用方法を示します。 この例では、`People.txt` が `Person`構造のレコードを含むファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="FromRecord">省略可能。 ロックまたはアンロックされる最初のレコードまたはバイトの番号。</param>
        <param name="ToRecord">省略可能。 ロックまたはアンロックされる最後のレコードまたはバイトの番号。</param>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` および `Unlock` 関数は、複数のプロセスが同じファイルへのアクセスを必要とする環境で使用されます。  
  
 `Lock` 関数と `Unlock` 関数は、常にペアで使用されます。 `Lock` と `Unlock` の引数は、同一である必要があります。  
  
 `Record`、または `FromRecord` と `ToRecord` が指定されていない場合、ファイル全体に対してロックが設定されます。 `Record` だけを指定した場合は、1つのレコードがロックまたはロック解除されます。  
  
 ファイルがシーケンシャル入力または出力用に開かれている場合、`FromRecord` と`ToRecord`で指定された範囲に関係なく、`Lock` と `Unlock` はファイル全体に影響します。  
  
   
  
## Examples  
 この例では、`Lock` 関数と `Unlock` 関数の使用方法を示します。 この例では、`People.txt` が `Person`構造のレコードを含むファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LOF(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 有効なファイル番号が格納された整数です。</param>
        <summary><see langword="FileOpen" /> 関数を使用して開かれたファイルのサイズをバイト単位で返します。 <see langword="My" /> 機能を使用すると、 <see langword="LOF" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <returns><see langword="FileOpen" /> 関数を使用して開かれたファイルのサイズ (バイト単位)。 <see langword="My" /> 機能を使用すると、 <see langword="LOF" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開かれていないファイルの長さを取得するには、`FileLen` 関数を使用します。  
  
   
  
## Examples  
 この例では、`LOF` 関数を使用して、開いているファイルのサイズを決定します。 この例では、`TestFile` がサンプルデータを含むテキストファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MkDir(string Path) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必須。 作成されるディレクトリを識別する文字列式です。 <paramref name="Path" /> にはドライブを含めることができます。 ドライブを指定しない場合、<see langword="MkDir" /> は現在のドライブに新しいディレクトリを作成します。</param>
        <summary>新しいディレクトリを作成します。 <see langword="My" /> 機能を使用すると、 <see langword="MkDir" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この関数は、新しいディレクトリを作成します。  
  
   
  
## Examples  
 この例では、`MkDir` 関数を使用してディレクトリを作成します。 ドライブが指定されていない場合は、現在のドライブに新しいディレクトリが作成されます。  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> が指定されていません。または空です。</exception>
        <exception cref="T:System.Security.SecurityException">アクセス許可は拒否されました。</exception>
        <exception cref="T:System.IO.IOException">ディレクトリが既に存在しています。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory">方法 : Visual Basic でディレクトリを作成する</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Print(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Output">省略可能。 ファイルへ書き込む 0 個以上のコンマで区切られた式。  
  
<paramref name="Output" /> 引数の設定は以下の通りです。 
 <see langword="T:System.IO.IOException" />: ファイル モードが有効ではありません。  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> が存在しません。</param>
        <summary>表示形式データをシーケンシャル ファイルに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print` 関数と `PrintLine` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Print` には、行の末尾に改行が含まれていません。ただし、`PrintLine` にはラインフィードが含まれます。  
  
 通常、`Print` で書き込まれたデータは、`LineInput` または `Input`を使用してファイルから読み取られます。  
  
 `PrintLine`に対して `Output` を省略した場合、空白行がファイルに出力されます。`Print`の場合、何も出力されません。 コンマで区切られた複数の式はタブ境界に沿って配置されますが、コンマと `TAB` が混在していると結果が矛盾する可能性があります。  
  
 `Boolean` データの場合、`True` または `False` のいずれかが印刷されます。 ロケールに関係なく、`True` キーワードと `False` キーワードは翻訳されません。  
  
 日付データは、システムによって認識される標準の短い日付形式を使用してファイルに書き込まれます。 日付または時刻コンポーネントが見つからないかゼロの場合は、指定された部分だけがファイルに書き込まれます。  
  
 `Output` データが空の場合、ファイルには何も書き込まれません。 ただし、`Output` リストのデータが `DBNull`場合は、`Null` がファイルに書き込まれます。  
  
 `Error` データの場合、出力は `Error errorcode`として表示されます。 `Error` キーワードは、ロケールに関係なく変換されません。  
  
 `Print` を使用してファイルに書き込まれるすべてのデータは、国際的に認識されます。つまり、適切な小数点区切り記号を使用してデータが正しく書式設定されます。 ユーザーが複数のロケールで使用するデータを出力する場合は、`Write` を使用する必要があります。  
  
 `Print` または `PrintLine` 関数を使用してファイルに書き込むには、`FileIOPermissionAccess` 列挙からの `Write` アクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Print` 関数と `PrintLine` 関数を使用して、データをファイルに書き込みます。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrintLine(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Output">省略可能。 ファイルへ書き込む 0 個以上のコンマで区切られた式。  
  
<paramref name="Output" /> 引数の設定は以下の通りです。 
 <see langword="T:System.IO.IOException" />: ファイル モードが有効ではありません。  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> が存在しません。</param>
        <summary>表示形式データをシーケンシャル ファイルに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print` 関数と `PrintLine` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Print` には、行の末尾に改行が含まれていません。ただし、`PrintLine` にはラインフィードが含まれます。  
  
 通常、`Print` で書き込まれたデータは、`LineInput` または `Input`を使用してファイルから読み取られます。  
  
 `PrintLine`に対して `Output` を省略した場合、空白行がファイルに出力されます。`Print`の場合、何も出力されません。 コンマで区切られた複数の式はタブ境界に沿って配置されますが、コンマと `TAB` が混在していると結果が矛盾する可能性があります。  
  
 `Boolean` データの場合、`True` または `False` のいずれかが印刷されます。 ロケールに関係なく、`True` キーワードと `False` キーワードは翻訳されません。  
  
 日付データは、システムによって認識される標準の短い日付形式を使用してファイルに書き込まれます。 日付または時刻コンポーネントが見つからないかゼロの場合は、指定された部分だけがファイルに書き込まれます。  
  
 `Output` データが空の場合、ファイルには何も書き込まれません。 ただし、`Output` リストのデータが `DBNull`場合は、`Null` がファイルに書き込まれます。  
  
 `Error` データの場合、出力は `Error errorcode`として表示されます。 `Error` キーワードは、ロケールに関係なく変換されません。  
  
 `Print` を使用してファイルに書き込まれるすべてのデータは、国際的に認識されます。つまり、適切な小数点区切り記号を使用してデータが正しく書式設定されます。 ユーザーが複数のロケールで使用するデータを出力する場合は、`Write` を使用する必要があります。  
  
 `Print` または `PrintLine` 関数を使用してファイルに書き込むには、`FileIOPermissionAccess` 列挙からの `Write` アクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Print` 関数と `PrintLine` 関数を使用して、データをファイルに書き込みます。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Rename(string OldPath, string NewPath) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">必須。 既存のファイルの名前と場所を指定する文字列式です。 <paramref name="OldPath" /> には、ファイルのディレクトリおよびドライブを含めることができます。</param>
        <param name="NewPath">必須。 新しいファイルの名前と場所を指定する文字列式です。 <paramref name="NewPath" /> には、出力先のディレクトリおよびドライブを含めることができます。 <paramref name="NewPath" /> には、既に存在しているファイル名は指定できません。</param>
        <summary>ディスク ファイルまたはディレクトリの名前を変更します。 <see langword="My" /> 機能を使用すると、 <see langword="Rename" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename` 関数は、ファイルの名前を変更し、必要に応じて別のディレクトリに移動します。 `Rename` 関数は、ドライブ間でファイルを移動できますが、`NewPath` と `OldPath` の両方が同じドライブに配置されている場合にのみ、既存のディレクトリの名前を変更できます。 新しいファイルまたはディレクトリを作成 `Rename` ことはできません。  
  
 開いているファイルで `Rename` 関数を使用すると、エラーが生成されます。 名前を変更する前に、開いているファイルを閉じる必要があります。 `Rename` の引数には、複数の文字 (*) と1文字 (?) のワイルドカードを含めることはできません。  
  
> [!IMPORTANT]
>  `Rename` を使用して保護されていない場所から保護された場所にファイルをコピーする場合、ファイルは制限の少ない権限を保持します。 セキュリティリスクが生じる可能性がないことを確認してください。  
  
   
  
## Examples  
 この例では、`Rename` 関数を使用してファイルの名前を変更します。 この例では、指定されたディレクトリが既に存在することを前提としています。  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">パスが無効です。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="OldPath" /> file does not exist.</exception>
        <exception cref="T:System.IO.IOException">異なるデバイスには名前を変更できません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file">方法 : Visual Basic でファイルの名前を変更する</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reset() cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="FileOpen" /> 関数を使用して開いたすべてのディスク ファイルを閉じます。 <see langword="My" /> 機能を使用すると、 <see langword="Reset" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Reset` 関数は、`FileOpen` 関数によって開かれたすべてのアクティブなファイルを閉じ、パラメーターを指定せずに `FileClose()` と同じ機能を持ちます。  
  
   
  
## Examples  
 この例では、`Reset` 関数を使用して開いているすべてのファイルを閉じ、すべてのファイルバッファーの内容をディスクに書き込みます。 `Object` 変数 `FileNumber` 文字列と数値の両方として使用されていることに注意してください。  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/statements/end-statement">End ステートメント</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RmDir(string Path) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必須。 削除するディレクトリまたはフォルダーを識別する文字列式です。 <paramref name="Path" /> にはドライブを含めることができます。 ドライブを指定しない場合、<see langword="RmDir" /> は現在のドライブのディレクトリを削除します。</param>
        <summary>既存のディレクトリを削除します。 <see langword="My" /> 機能を使用すると、 <see langword="RmDir" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイルが格納されているディレクトリで `RmDir` を使用しようとすると、エラーが発生します。 `Kill` 関数を使用して、ディレクトリを削除する前にすべてのファイルを削除します。  
  
   
  
## Examples  
 この例では、`RmDir` 関数を使用して、既存のディレクトリを削除します。  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> が指定されていません。または空です。</exception>
        <exception cref="T:System.IO.IOException">対象のディレクトリにファイルが存在しています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ディレクトリが存在していません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see langword="Long" /> 関数を使用して開いたファイル内の現在の読み込み位置または書き込み位置を示す <see langword="FileOpen" /> を返します。また、<see langword="FileOpen" /> 関数で開いたファイルの、次に読み込みまたは書き込みを行う位置を設定します。 <see langword="My" /> 機能を使用すると、 <see langword="Seek" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Seek(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 有効なファイル番号が含まれている <see langword="Integer" /> 型の値。</param>
        <summary><see langword="Long" /> 関数を使用して開いたファイル内の現在の読み込み位置または書き込み位置を示す <see langword="FileOpen" /> を返します。また、<see langword="FileOpen" /> 関数で開いたファイルの、次に読み込みまたは書き込みを行う位置を設定します。 <see langword="My" /> 機能を使用すると、 <see langword="Seek" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <returns><see langword="Long" /> 関数を使用して開いたファイル内の現在の読み込み位置または書き込み位置を示す <see langword="FileOpen" />。または、<see langword="FileOpen" /> 関数を使用して開いたファイルの、次に読み込みまたは書き込みを行う位置を設定します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` は、1 ~ 2147483647 (2 ^ 31-1 に相当) の値を返します。  
  
 次に、各ファイルアクセスモードの戻り値について説明します。  
  
|モード|戻り値|  
|-|-|  
|`Random`|次のレコードの読み取りまたは書き込みの番号|  
|`Binary`、`Input`、`Output`, `Append`|次の操作が発生するバイト位置。 ファイルの最初のバイトの位置は1で、2番目のバイトは2の位置にあります。|  
  
   
  
## Examples  
 この例では、`Seek` 関数を使用して、現在のファイルの位置を返します。 この例では `TestFile` が `Record`構造のレコードを含むファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 `Random` モードで開かれたファイルの場合、`Seek` は次のレコードの数を返します。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 `Random` モード以外のモードで開かれたファイルの場合、`Seek` は次の操作が行われるバイト位置を返します。 `TestFile` が複数行のテキストを含むファイルであるとします。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 この例では、`Seek` 関数を使用して、ファイル内の次の読み取りまたは書き込みの位置を設定します。  
  
 `Random` モード以外のモードで開かれたファイルの場合、`Seek` は次の操作が行われるバイト位置を設定します。 `TestFile` が複数行のテキストを含むファイルであるとします。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Seek(int32 FileNumber, int64 Position) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 有効なファイル番号が含まれている <see langword="Integer" /> 型の値。</param>
        <param name="Position">必須。 次の読み書き操作が発生する場所を示す 1 から 2,147,483,647 の範囲の数値。</param>
        <summary><see langword="Long" /> 関数を使用して開いたファイル内の現在の読み込み位置または書き込み位置を示す <see langword="FileOpen" /> を返します。また、<see langword="FileOpen" /> 関数で開いたファイルの、次に読み込みまたは書き込みを行う位置を設定します。 <see langword="My" /> 機能を使用すると、 <see langword="Seek" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` は、1 ~ 2147483647 (2 ^ 31-1 に相当) の値を返します。  
  
 次に、各ファイルアクセスモードの戻り値について説明します。  
  
|モード|戻り値|  
|-|-|  
|`Random`|次のレコードの読み取りまたは書き込みの番号|  
|`Binary`、`Input`、`Output`, `Append`|次の操作が発生するバイト位置。 ファイルの最初のバイトの位置は1で、2番目のバイトは2の位置にあります。|  
  
   
  
## Examples  
 この例では、`Seek` 関数を使用して、現在のファイルの位置を返します。 この例では `TestFile` が `Record`構造のレコードを含むファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 `Random` モードで開かれたファイルの場合、`Seek` は次のレコードの数を返します。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 `Random` モード以外のモードで開かれたファイルの場合、`Seek` は次の操作が行われるバイト位置を返します。 `TestFile` が複数行のテキストを含むファイルであるとします。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 この例では、`Seek` 関数を使用して、ファイル内の次の読み取りまたは書き込みの位置を設定します。  
  
 `Random` モード以外のモードで開かれたファイルの場合、`Seek` は次の操作が行われるバイト位置を設定します。 `TestFile` が複数行のテキストを含むファイルであるとします。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">必須。 ファイル名を指定する文字列式です。 <paramref name="PathName" /> にはディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <param name="Attributes">必須。 定数式または数式の合計がファイル属性を指定する場合の定数式または数式。</param>
        <summary>ファイルの属性情報を設定します。 <see langword="My" /> 機能を使用すると、 <see langword="SetAttr" />よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開いているファイルの属性を設定しようとすると、実行時エラーが発生します。  
  
 `Attributes` 引数の列挙値は次のとおりです。  
  
|値|常時|説明|  
|-|-|-|  
|`Normal`|`vbNormal`|Normal (既定値)。|  
|`ReadOnly`|`vbReadOnly`|読み取り専用です。|  
|`Hidden`|`vbHidden`|Hidden。|  
|`System`|`vbSystem`|システム ファイル。|  
|`Volume`|`vbVolume`|ボリューム ラベル|  
|`Directory`|`vbDirectory`|ディレクトリまたはフォルダー。|  
|`Archive`|`vbArchive`|ファイルは前回のバックアップ以降に変更されています。|  
|`Alias`|`vbAlias`|ファイルに別の名前が付いています。|  
  
> [!NOTE]
>  これらの列挙体は Visual Basic 言語によって指定されています。 名前は、実際の値ではなく、コード内の任意の場所で使用できます。  
  
   
  
## Examples  
 この例では、`SetAttr` 関数を使用して、ファイルの属性を設定します。  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Attribute" /> の型が無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">必須。 リストの次の式を表示または出力する前に挿入する空白の数。</param>
        <summary><see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</summary>
        <returns><see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Count` が出力線の幅よりも小さい場合は、次の印刷位置が、印刷されるスペースの数の直後になります。 `Count` が出力線の幅より大きい場合、`SPC` は次の式を使用して次の印刷位置を計算します。  
  
 `currentprintposition`(+ (`Count``Mod``width`))  
  
 たとえば、現在の印刷位置が24で、出力線の幅が80で、`SPC(90)`を指定した場合、次の印刷は位置 34 (現在の印刷位置 + 90/80 の剰余) から開始されます。 現在の印刷位置と出力行の幅の差が `Count` (または `Count` `Mod`*幅*) よりも小さい場合、`SPC` 関数は次の行の先頭にスキップし、`Count`-(*width* - *currentprintposition*) と同じスペースを生成します。  
  
> [!NOTE]
>  表形式の列に、ワイド文字を許可するのに十分な幅があることを確認します。  
  
   
  
## Examples  
 この例では、`SPC` 関数を使用して、出力をファイルと**出力**ウィンドウに配置します。  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/operators/mod-operator">Mod 演算子 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</summary>
        <returns><see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の行の現在の印刷位置が `Column`より大きい場合、`TAB` は次の出力行の `Column` に等しい列値にスキップします。 `Column` が1未満の場合、`TAB` は印刷位置を列1に移動します。 `Column` が出力線の幅より大きい場合、`TAB` は次の式を使用して次の印刷位置を計算します。  
  
 列の Mod の幅  
  
 たとえば、 *width*が80で `TAB(90)`指定した場合、次の印刷は列 10 (90/80 の剰余) から開始されます。 `Column` が現在の印刷位置より小さい場合は、計算された印刷位置の次の行で印刷が開始されます。 計算された印刷位置が現在の印刷位置より大きい場合は、同じ行の計算された印刷位置から印刷が開始されます。  
  
 出力行の左端の印刷位置は常に1です。 `Print` または `PrintLine` 関数を使用してファイルに出力すると、出力ファイルの現在の幅が右端の印刷位置になります。これは、`FileWidth` 関数を使用して設定できます。  
  
 `TAB` 関数は、`WriteLine` 関数と共に使用することもできます。 <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> または <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>と共に使用することはできません。  
  
> [!NOTE]
>  表形式の列に、ワイド文字を格納するのに十分な幅があることを確認します。  
  
   
  
## Examples  
 この例では、`TAB` 関数を使用して、出力をファイルと**出力**ウィンドウに配置します。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/operators/mod-operator">Mod 演算子 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">省略可能。 リスト内の次の式を表示または出力する前に移動する先の列番号。 省略した場合、<see langword="TAB" /> は挿入位置を次の印字領域の最初に移動します。</param>
        <summary><see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</summary>
        <returns><see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の行の現在の印刷位置が `Column`よりも大きい場合、`TAB` は次の出力行の `Column` に等しい列値にスキップします。 `Column` が1未満の場合、`TAB` は印刷位置を列1に移動します。 `Column` が出力線の幅より大きい場合、`TAB` は次の式を使用して次の印刷位置を計算します。  
  
 列の Mod の幅  
  
 たとえば、 *width*が80で `TAB(90)`指定した場合、次の印刷は列 10 (90/80 の剰余) から開始されます。 `Column` が現在の印刷位置より小さい場合は、計算された印刷位置の次の行で印刷が開始されます。 計算された印刷位置が現在の印刷位置より大きい場合は、同じ行の計算された印刷位置から印刷が開始されます。  
  
 出力行の左端の印刷位置は常に1です。 `Print` または `PrintLine` 関数を使用してファイルに出力すると、出力ファイルの現在の幅が右端の印刷位置になります。これは、`FileWidth` 関数を使用して設定できます。  
  
 `TAB` 関数は、`WriteLine` 関数と共に使用することもできます。 <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> または <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>と共に使用することはできません。  
  
> [!NOTE]
>  表形式の列に、ワイド文字を格納するのに十分な幅があることを確認します。  
  
   
  
## Examples  
 この例では、`TAB` 関数を使用して、出力をファイルと**出力**ウィンドウに配置します。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/operators/mod-operator">Mod 演算子 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unlock(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` および `Unlock` 関数は、複数のプロセスが同じファイルへのアクセスを必要とする環境で使用されます。  
  
 `Lock` 関数と `Unlock` 関数は、常にペアで使用されます。 `Lock` と `Unlock` の引数は、同一である必要があります。  
  
 `Record`、または `FromRecord` と `ToRecord` が指定されていない場合、ファイル全体に対してロックが設定されます。 `Record` だけを指定した場合は、1つのレコードがロックまたはロック解除されます。  
  
 ファイルがシーケンシャル入力または出力用に開かれている場合、`FromRecord` と`ToRecord`で指定された範囲に関係なく、`Lock` と `Unlock` はファイル全体に影響します。  
  
   
  
## Examples  
 この例では、`Lock` 関数と `Unlock` 関数の使用方法を示します。 この例では、`People.txt` が `Person`構造のレコードを含むファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unlock(int32 FileNumber, int64 Record) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Record">省略可能。 ロックまたはアンロックされる唯一のレコードまたはバイトの番号。</param>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` および `Unlock` 関数は、複数のプロセスが同じファイルへのアクセスを必要とする環境で使用されます。  
  
 `Lock` 関数と `Unlock` 関数は、常にペアで使用されます。 `Lock` と `Unlock` の引数は、同一である必要があります。  
  
 `Record`、または `FromRecord` と `ToRecord` が指定されていない場合、ファイル全体に対してロックが設定されます。 `Record` だけを指定した場合は、1つのレコードがロックまたはロック解除されます。  
  
 ファイルがシーケンシャル入力または出力用に開かれている場合、`FromRecord` と`ToRecord`で指定された範囲に関係なく、`Lock` と `Unlock` はファイル全体に影響します。  
  
   
  
## Examples  
 この例では、`Lock` 関数と `Unlock` 関数の使用方法を示します。 この例では、`People.txt` が `Person`構造のレコードを含むファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="FromRecord">省略可能。 ロックまたはアンロックされる最初のレコードまたはバイトの番号。</param>
        <param name="ToRecord">省略可能。 ロックまたはアンロックされる最後のレコードまたはバイトの番号。</param>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` および `Unlock` 関数は、複数のプロセスが同じファイルへのアクセスを必要とする環境で使用されます。  
  
 `Lock` 関数と `Unlock` 関数は、常にペアで使用されます。 `Lock` と `Unlock` の引数は、同一である必要があります。  
  
 `Record`、または `FromRecord` と `ToRecord` が指定されていない場合、ファイル全体に対してロックが設定されます。 `Record` だけを指定した場合は、1つのレコードがロックまたはロック解除されます。  
  
 ファイルがシーケンシャル入力または出力用に開かれている場合、`FromRecord` と`ToRecord`で指定された範囲に関係なく、`Lock` と `Unlock` はファイル全体に影響します。  
  
   
  
## Examples  
 この例では、`Lock` 関数と `Unlock` 関数の使用方法を示します。 この例では、`People.txt` が `Person`構造のレコードを含むファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数を含む <see langword="Integer" /> 式。</param>
        <param name="Output">省略可能。 ファイルへ書き込む 1 個以上のコンマで区切られた式。</param>
        <summary>シーケンシャル ファイルにデータを書き込みます。 <see langword="Write" /> を使用して書き込まれたデータは通常、 <see langword="Input" />を使用してファイルから読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write` 関数と `WriteLine` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Output`を省略した場合は、空白行がファイルに出力されます。 複数の式は、コンマで区切ることができます。  
  
 `Print` 関数とは異なり、`Write` 関数は、ファイルに書き込まれるときに文字列の前後にコンマを挿入します。 明示的な区切り記号を一覧に含める必要はありません。 データをファイルに書き込むために `Write` を使用する場合、数値、`Boolean`、日付、null、および `Error` のデータ形式のみがサポートされます。 次の汎用的な仮定に従うと、ロケールに関係なく、常に `Input`を使用してデータを読み取って正しく解釈できます。  
  
-   数値データは、常に小数点区切り文字としてピリオドを使用して書き込まれます。  
  
-   `Boolean` データの場合、`#TRUE#` または `#FALSE#` のいずれかが印刷されます。 ロケールに関係なく、`True` キーワードと `False` キーワードは翻訳されません。  
  
-   日付データは、ユニバーサル日付形式を使用してファイルに書き込まれます。 日付または時刻コンポーネントが見つからないかゼロの場合は、指定された部分だけがファイルに書き込まれます。  
  
-   `Output` データが空の場合、ファイルには何も書き込まれません。 ただし、null データの場合は `#NULL#` が書き込まれます。  
  
-   `Error` データの場合、出力は `#ERROR errorcode#`として表示されます。 `Error` キーワードは、ロケールに関係なく、変換されません。  
  
 `WriteLine` は、`Output` の最後の文字がファイルに書き込まれた後に、改行文字 (つまり、復帰/ラインフィード、または `Chr(13) + Chr(10)`) を挿入します。  
  
 二重引用符または "" を使用して、文字列に引用符を埋め込むことができます。 たとえば、次のように入力します。  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 `Double quotation marks aren't "difficult" to handle`の値を持つ文字列を返します。  
  
 `Write` または `WriteLine` 関数を使用してファイルに書き込むには、`FileIOPermissionAccess` 列挙からの `Append` アクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Write` 関数を使用して、生データをシーケンシャルファイルに書き込みます。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数を含む <see langword="Integer" /> 式。</param>
        <param name="Output">省略可能。 ファイルへ書き込む 1 個以上のコンマで区切られた式。</param>
        <summary>シーケンシャル ファイルにデータを書き込みます。 <see langword="Write" /> を使用して書き込まれたデータは通常、 <see langword="Input" />を使用してファイルから読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write` 関数と `WriteLine` 関数は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションの場合、`My.Computer.FileSystem` オブジェクトによってパフォーマンスが向上します。 詳しくは、「[Visual Basic におけるファイル アクセス](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access)」をご覧ください。  
  
 `Output`を省略した場合は、空白行がファイルに出力されます。 複数の式は、コンマで区切ることができます。  
  
 `Print` 関数とは異なり、`Write` 関数は、ファイルに書き込まれるときに文字列の前後にコンマを挿入します。 明示的な区切り記号を一覧に含める必要はありません。 データをファイルに書き込むために `Write` を使用する場合、数値、`Boolean`、日付、null、および `Error` のデータ形式のみがサポートされます。 次の汎用的な仮定に従うと、ロケールに関係なく、常に `Input`を使用してデータを読み取って正しく解釈できます。  
  
-   数値データは、常に小数点区切り文字としてピリオドを使用して書き込まれます。  
  
-   `Boolean` データの場合、`#TRUE#` または `#FALSE#` のいずれかが印刷されます。 ロケールに関係なく、`True` キーワードと `False` キーワードは翻訳されません。  
  
-   日付データは、ユニバーサル日付形式を使用してファイルに書き込まれます。 日付または時刻コンポーネントが見つからないかゼロの場合は、指定された部分だけがファイルに書き込まれます。  
  
-   `Output` データが空の場合、ファイルには何も書き込まれません。 ただし、null データの場合は `#NULL#` が書き込まれます。  
  
-   `Error` データの場合、出力は `#ERROR errorcode#`として表示されます。 `Error` キーワードは、ロケールに関係なく、変換されません。  
  
 `WriteLine` は、`Output` の最後の文字がファイルに書き込まれた後に、改行文字 (つまり、復帰/ラインフィード、または `Chr(13) + Chr(10)`) を挿入します。  
  
 二重引用符または "" を使用して、文字列に引用符を埋め込むことができます。 たとえば、次のように入力します。  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 `Double quotation marks aren't "difficult" to handle`の値を持つ文字列を返します。  
  
 `Write` または `WriteLine` 関数を使用してファイルに書き込むには、`FileIOPermissionAccess` 列挙からの `Append` アクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Write` 関数を使用して、生データをシーケンシャルファイルに書き込みます。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">方法: Streamwriter を使用してファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
  </Members>
</Type>
