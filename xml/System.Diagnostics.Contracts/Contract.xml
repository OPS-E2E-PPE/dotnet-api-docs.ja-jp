<Type Name="Contract" FullName="System.Diagnostics.Contracts.Contract">
  <Metadata><Meta Name="ms.openlocfilehash" Value="19191472f8be59b170b9ad3f6d1f350837d1bd10" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82335964" /></Metadata><TypeSignature Language="C#" Value="public static class Contract" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Contract extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Contracts.Contract" />
  <TypeSignature Language="VB.NET" Value="Public Class Contract" />
  <TypeSignature Language="C++ CLI" Value="public ref class Contract abstract sealed" />
  <TypeSignature Language="F#" Value="type Contract = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Diagnostics.Contracts" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="00f0f-101">実行前の状態、実行後の状態、オブジェクトの不変部分などのプログラム コントラクトを表す静的メソッドを格納します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-101">Contains static methods for representing program contracts such as preconditions, postconditions, and object invariants.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-102">コードコントラクトクラスを使用すると、コード内で事前条件、事後条件、およびオブジェクトの不変性を指定できます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-102">Code contract classes let you specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="00f0f-103">事前条件とは、メソッドやプロパティに入るときに満たされている必要がある要件です。</span><span class="sxs-lookup"><span data-stu-id="00f0f-103">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="00f0f-104">事後条件は、メソッドやプロパティのコードが終了するときの予測を表します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-104">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="00f0f-105">オブジェクトインバリアントは、条件の問題がないクラスに予期される状態を記述します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-105">Object invariants describe the expected state for a class that has no condition problems.</span></span> <span data-ttu-id="00f0f-106">事前条件、事後条件、およびオブジェクトの不変性の詳細については、「[コードコントラクト](~/docs/framework/debug-trace-profile/code-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="00f0f-106">For more information about preconditions, postconditions, and object invariants, see [Code Contracts](~/docs/framework/debug-trace-profile/code-contracts.md).</span></span>  
  
 <span data-ttu-id="00f0f-107">コードコントラクトを使用するためのツールと詳細な手順については、Visual Studio Marketplace の[コードコントラクト](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET)に関する記述を参照してください。</span><span class="sxs-lookup"><span data-stu-id="00f0f-107">For tools and detailed instructions for using code contracts, see [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio Marketplace.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="00f0f-108">バイナリリライターを使用して、コントラクトの実行時の適用を挿入する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-108">You must use a binary rewriter to insert run-time enforcement of contracts.</span></span> <span data-ttu-id="00f0f-109">それ以外の場合、<xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> メソッドなどのコントラクトは静的にのみテストでき、コントラクトに違反した場合は実行時に例外をスローしません。</span><span class="sxs-lookup"><span data-stu-id="00f0f-109">Otherwise, contracts such as the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> method can only be tested statically and will not throw exceptions during run time if a contract is violated.</span></span> <span data-ttu-id="00f0f-110">Visual Studio Marketplace で[コードコントラクト](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET)からバイナリリライター CCRewrite をダウンロードできます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-110">You can download the binary rewriter CCRewrite from [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio Marketplace.</span></span> <span data-ttu-id="00f0f-111">CCRewrite には、プロジェクトの **[プロパティ]** ページからランタイムコントラクトの適用をアクティブ化できる Visual Studio アドインが付属しています。</span><span class="sxs-lookup"><span data-stu-id="00f0f-111">CCRewrite comes with a Visual Studio add-in that enables you to activate run-time contract enforcement from the project **Properties** page.</span></span> <span data-ttu-id="00f0f-112">バイナリリライターと Visual Studio アドインには、[!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] または Windows SDK が付属していません。</span><span class="sxs-lookup"><span data-stu-id="00f0f-112">The binary rewriter and the Visual Studio add-in do not ship with [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] or the Windows SDK.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="00f0f-113">デバッグ ビルドで、指定された条件のランタイム テストを実行します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-113">In debug builds, performs a run-time test for a specified condition.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assert : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assert condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="00f0f-114">テストする条件式。</span><span class="sxs-lookup"><span data-stu-id="00f0f-114">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="00f0f-115">条件をチェックし、その条件が <see langword="false" /> の場合は、アナライザーに設定されたエスカレーション ポリシーに従います。</span><span class="sxs-lookup"><span data-stu-id="00f0f-115">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set for the analyzer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-116">既定のエスカレーションポリシーでは、アタッチされたデバッガーに対してコントラクトエラーに関する通知を行います。デバッガーがアタッチされていない場合は、**アサート**ダイアログボックスを表示します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-116">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="00f0f-117">必要に応じて、アナライザーに例外をスローするように指示できます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-117">Optionally, the analyzer can be instructed to throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Assert : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assert (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="00f0f-118">テストする条件式。</span><span class="sxs-lookup"><span data-stu-id="00f0f-118">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="00f0f-119">条件が一致しない場合に表示するメッセージ。</span><span class="sxs-lookup"><span data-stu-id="00f0f-119">A message to display if the condition is not met.</span></span></param>
        <summary><span data-ttu-id="00f0f-120">条件をチェックし、その条件が <see langword="false" /> の場合は、アナライザーによって設定されたエスカレーション ポリシーに従い、指定されたメッセージを表示します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-120">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set by the analyzer and displays the specified message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-121">既定のエスカレーションポリシーでは、アタッチされたデバッガーに対してコントラクトエラーに関する通知を行います。デバッガーがアタッチされていない場合は、**アサート**ダイアログボックスを表示します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-121">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="00f0f-122">必要に応じて、アナライザーに例外をスローするように指示できます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-122">Optionally, the analyzer can be instructed to throw an exception.</span></span> <span data-ttu-id="00f0f-123">`userMessage` パラメーターは、デバッガーの出力に渡されます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-123">The `userMessage` parameter is passed to the debugger output.</span></span> <span data-ttu-id="00f0f-124">`userMessage` が定数文字列リテラルではない場合、ツールはそれを読み取ることができない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-124">If `userMessage` is not a constant string literal, tools may not be able to read it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Assume">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="00f0f-125">常に <see langword="true" /> であるとは静的に証明されない場合でも、条件が <see langword="true" /> であると想定するようコード分析ツールに指示します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-125">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assume : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assume condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="00f0f-126"><see langword="true" /> に想定する条件式。</span><span class="sxs-lookup"><span data-stu-id="00f0f-126">The conditional expression to assume <see langword="true" />.</span></span></param>
        <summary><span data-ttu-id="00f0f-127">常に <see langword="true" /> であるとは静的に証明されない場合でも、指定された条件が <see langword="true" /> であると想定するようコード分析ツールに指示します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-127">Instructs code analysis tools to assume that the specified condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-128">実行時に、このメソッドを使用することは、<xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> メソッドを使用することと同じです。</span><span class="sxs-lookup"><span data-stu-id="00f0f-128">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Assume : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assume (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="00f0f-129"><see langword="true" /> に想定する条件式。</span><span class="sxs-lookup"><span data-stu-id="00f0f-129">The conditional expression to assume <see langword="true" />.</span></span></param>
        <param name="userMessage"><span data-ttu-id="00f0f-130">想定が失敗した場合にポストするメッセージ。</span><span class="sxs-lookup"><span data-stu-id="00f0f-130">The message to post if the assumption fails.</span></span></param>
        <summary><span data-ttu-id="00f0f-131">常に <see langword="true" /> であるとは静的に証明されない場合でも、条件が <see langword="true" /> であると想定するようコード分析ツールに指示し、想定が失敗した場合はメッセージを表示します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-131">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />, and displays a message if the assumption fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-132">`userMessage` が定数文字列リテラルでない場合は、ツールによってコントラクトが認識されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-132">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 <span data-ttu-id="00f0f-133">実行時に、このメソッドを使用することは、<xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> メソッドを使用することと同じです。</span><span class="sxs-lookup"><span data-stu-id="00f0f-133">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractFailed">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Contracts.Contract.ContractFailed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ContractFailed As EventHandler(Of ContractFailedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Diagnostics::Contracts::ContractFailedEventArgs ^&gt; ^ ContractFailed;" />
      <MemberSignature Language="F#" Value="member this.ContractFailed : EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; " Usage="member this.ContractFailed : System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="00f0f-134">コントラクトが失敗すると発生します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-134">Occurs when a contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-135">このイベントのイベント情報は、イベントハンドラーに渡される <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> オブジェクトによって提供されます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-135">The event information for this event is supplied by the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> object that is passed to the event handler.</span></span> <span data-ttu-id="00f0f-136">このイベントは、コントラクトが失敗したことを、対話型インタープリターや Web ブラウザーホストなどのマネージアプリケーション環境に通知します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-136">This event notifies a managed application environment such as an interactive interpreter or a Web browser host that a contract has failed.</span></span> <span data-ttu-id="00f0f-137">この操作を行う前に、アプリケーションが適合するときに処理できるイベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-137">Before doing so, it will raise an event that an application can handle as it sees fit.</span></span> <span data-ttu-id="00f0f-138">たとえば、コードがテストフレームワークで実行されている場合は、テストエラーをログに記録してから、テストを終了できます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-138">For example, if code is being run in a testing framework, you can log a test failure and then end the test.</span></span>  
  
 <span data-ttu-id="00f0f-139">.NET Framework クラスライブラリの <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> メソッドの既定の実装では、<xref:System.Diagnostics.Contracts.Contract.ContractFailed> イベントに登録されている各ハンドラーを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-139">The default implementation of the <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> method in the .NET Framework class library is to call each handler that is registered with the <xref:System.Diagnostics.Contracts.Contract.ContractFailed> event.</span></span> <span data-ttu-id="00f0f-140">ハンドラーによってスローされる例外は無視されますが、各ハンドラーは、イベント引数の <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> メソッドを呼び出すことによって、エラーが処理されるかどうかを示すことができます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-140">Exceptions thrown by handlers are ignored, but each handler can indicate whether the failure is handled by calling the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> method for the event arguments.</span></span> <span data-ttu-id="00f0f-141">いずれかのハンドラーがエラーを処理済みとして設定した場合、メソッドは `null` を返し、それ以上のアクションは実行されません。</span><span class="sxs-lookup"><span data-stu-id="00f0f-141">If any handler sets the failure as handled, the method returns `null` and no further action is taken.</span></span> <span data-ttu-id="00f0f-142">または、ハンドラーで <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> メソッドを呼び出して、アンワインドするコードを指示することもできます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-142">Alternatively, handlers can call the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> method to instruct the code to unwind.</span></span> <span data-ttu-id="00f0f-143">その場合、すべてのハンドラーの実行後に例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-143">In that case, an exception is thrown after all handlers have executed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndContractBlock">
      <MemberSignature Language="C#" Value="public static void EndContractBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndContractBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EndContractBlock" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndContractBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndContractBlock();" />
      <MemberSignature Language="F#" Value="static member EndContractBlock : unit -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.EndContractBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="00f0f-144">メソッドのコントラクトに <see langword="if" />-<see langword="then" />-<see langword="throw" /> の形式で実行前の状態のみが含まれる場合に、コントラクト セクションの終わりをマークします。</span><span class="sxs-lookup"><span data-stu-id="00f0f-144">Marks the end of the contract section when a method's contracts contain only preconditions in the <see langword="if" />-<see langword="then" />-<see langword="throw" /> form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-145">ほとんどのコードには、`if`-`then`-`throw` コードの形式でパラメーターの検証が既に含まれています。</span><span class="sxs-lookup"><span data-stu-id="00f0f-145">Most code already contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="00f0f-146">コントラクトツールは、ステートメントがメソッド内に最初に出現したときにステートメントが事前条件として `if`-`then`-を認識します。このようなステートメントのセット全体には、`throw`、<xref:System.Diagnostics.Contracts.Contract>、<xref:System.Diagnostics.Contracts.Contract.Requires%2A>、<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>などの明示的な <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>メソッド呼び出しが続きます。<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A></span><span class="sxs-lookup"><span data-stu-id="00f0f-146">The contract tools recognize `if`-`then`-`throw` statements as preconditions when the statements appear first inside a method, and the entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span></span>  
  
 <span data-ttu-id="00f0f-147">この形式で -`then`-`throw` ステートメントが `if`されると、コントラクトツールはそれらをレガシ要求ステートメントとして認識します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-147">When `if`-`then`-`throw` statements appear in this form, the contract tools recognize them as legacy-require statements.</span></span> <span data-ttu-id="00f0f-148"><xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> フォームが使用されるのは、その他のコントラクトが `if`-`then`-のシーケンスに従っていない場合に限られますが、従来の必須のタグを付けることができます。`throw`</span><span class="sxs-lookup"><span data-stu-id="00f0f-148">The <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> form is used only if no other contracts follow the `if`-`then`-`throw` sequences, but they should still be tagged as legacy-requires.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ensures">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="00f0f-149">外側のメソッドまたはプロパティの実行後の状態のコントラクトを指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-149">Specifies a postcondition contract for the enclosing method or property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition);" />
      <MemberSignature Language="F#" Value="static member Ensures : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Ensures condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="00f0f-150">テストする条件式。</span><span class="sxs-lookup"><span data-stu-id="00f0f-150">The conditional expression to test.</span></span> <span data-ttu-id="00f0f-151">式には <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />、<see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />、および <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> の各値を使用できます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-151">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />, and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span></span></param>
        <summary><span data-ttu-id="00f0f-152">外側のメソッドまたはプロパティの実行後の状態のコントラクトを指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-152">Specifies a postcondition contract for the enclosing method or property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-153">`condition` パラメーターは、外側のメソッドまたはプロパティが正常に返されたときに `true` されると想定される事後条件を指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-153">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="00f0f-154">このメソッドの呼び出しは、他のコードの前にあるメソッドまたはプロパティの先頭にある必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-154">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="00f0f-155">この事後条件の実行時の適用には、バイナリリライター (Visual Studio Marketplace の[コードコントラクト](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET)で利用可能) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-155">You must use the binary rewriter (available at [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio Marketplace) for run-time enforcement of this postcondition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00f0f-156">次の例は、<xref:System.Diagnostics.Contracts.Contract.Ensures%2A> メソッドを使用して、予期される値が返されることを確認する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="00f0f-156">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method to ensure that an expected value is returned.</span></span> <span data-ttu-id="00f0f-157">このコード例は、<xref:System.Diagnostics.Contracts.ContractClassAttribute> クラス用に用意されている大規模な例の一部です。</span><span class="sxs-lookup"><span data-stu-id="00f0f-157">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Ensures : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Ensures (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="00f0f-158">テストする条件式。</span><span class="sxs-lookup"><span data-stu-id="00f0f-158">The conditional expression to test.</span></span> <span data-ttu-id="00f0f-159">式には <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> および <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> の各値を使用できます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-159">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span></span></param>
        <param name="userMessage"><span data-ttu-id="00f0f-160">式が <see langword="true" /> でない場合に表示するメッセージ。</span><span class="sxs-lookup"><span data-stu-id="00f0f-160">The message to display if the expression is not <see langword="true" />.</span></span></param>
        <summary><span data-ttu-id="00f0f-161">指定された終了条件の実行後の状態のコントラクトと、条件が <see langword="false" /> の場合に表示するメッセージを指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-161">Specifies a postcondition contract for a provided exit condition and a message to display if the condition is <see langword="false" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-162">`condition` パラメーターは、外側のメソッドまたはプロパティが正常に返されたときに `true` されると想定される事後条件を指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-162">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="00f0f-163">このメソッドの呼び出しは、他のコードの前にあるメソッドまたはプロパティの先頭にある必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-163">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="00f0f-164">このコントラクトはクライアントに公開されます。したがって、少なくとも外側のメソッドとして表示されるメンバーのみを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-164">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="00f0f-165">この事後条件の実行時の適用には、バイナリリライター (Visual Studio Marketplace の[コードコントラクト](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET)で利用可能) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-165">You must use the binary rewriter (available at [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio Marketplace) for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="00f0f-166">`userMessage` が定数文字列リテラルでない場合は、ツールによってコントラクトが認識されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-166">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnsuresOnThrow&lt;TException&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="00f0f-167">指定された例外および条件に基づいて、外側のメソッドまたはプロパティに実行後の状態のコントラクトを指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-167">Specifies a postcondition contract for the enclosing method or property based on the provided exception and condition.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition);" />
      <MemberSignature Language="F#" Value="static member EnsuresOnThrow : bool -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.EnsuresOnThrow condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="00f0f-168">実行後の状態のチェックを起動する例外の種類。</span><span class="sxs-lookup"><span data-stu-id="00f0f-168">The type of exception that invokes the postcondition check.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="00f0f-169">テストする条件式。</span><span class="sxs-lookup"><span data-stu-id="00f0f-169">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="00f0f-170">指定された例外および条件に基づいて、外側のメソッドまたはプロパティに実行後の状態のコントラクトを指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-170">Specifies a postcondition contract for the enclosing method or property, based on the provided exception and condition.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-171">`condition` パラメーターは、外側のメソッドまたはプロパティが異常終了し、`TException` 型の例外がスローされた場合に `true` れることが予想される事後条件を指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-171">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span>  
  
-   <span data-ttu-id="00f0f-172">このメソッドの呼び出しは、他のコードの前にあるメソッドまたはプロパティの先頭にある必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-172">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="00f0f-173">このコントラクトはクライアントに公開されます。したがって、少なくとも外側のメソッドとして表示されるメンバーのみを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-173">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="00f0f-174">この事後条件の実行時の強制には、バイナリリライターを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-174">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member EnsuresOnThrow : bool * string -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.EnsuresOnThrow (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="00f0f-175">実行後の状態のチェックを起動する例外の種類。</span><span class="sxs-lookup"><span data-stu-id="00f0f-175">The type of exception that invokes the postcondition check.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="00f0f-176">テストする条件式。</span><span class="sxs-lookup"><span data-stu-id="00f0f-176">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="00f0f-177">式が <see langword="false" /> の場合に表示するメッセージ。</span><span class="sxs-lookup"><span data-stu-id="00f0f-177">The message to display if the expression is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="00f0f-178">指定された例外および条件に基づいて、実行後の状態のコントラクトと、外側のメソッドまたはプロパティの条件が <see langword="false" /> の場合に表示するメッセージを指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-178">Specifies a postcondition contract and a message to display if the condition is <see langword="false" /> for the enclosing method or property, based on the provided exception and condition.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-179">`condition` パラメーターは、外側のメソッドまたはプロパティが異常終了し、`TException` 型の例外がスローされた場合に `true` れることが予想される事後条件を指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-179">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span> <span data-ttu-id="00f0f-180">`message` パラメーターは、条件が `false`場合に表示するメッセージを指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-180">The `message` parameter specifies a message to display if the condition is `false`.</span></span>  
  
-   <span data-ttu-id="00f0f-181">このメソッドの呼び出しは、他のコードの前にあるメソッドまたはプロパティの先頭にある必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-181">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="00f0f-182">このコントラクトはクライアントに公開されます。したがって、少なくとも外側のメソッドとして表示されるメンバーのみを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-182">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="00f0f-183">この事後条件の実行時の強制には、バイナリリライターを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-183">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="00f0f-184">`userMessage` が定数文字列リテラルでない場合は、ツールによってコントラクトが認識されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-184">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Exists : int * int * Predicate&lt;int&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.Exists (fromInclusive, toExclusive, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="00f0f-185"><paramref name="predicate" /> に渡す最初の整数。</span><span class="sxs-lookup"><span data-stu-id="00f0f-185">The first integer to pass to <paramref name="predicate" />.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="00f0f-186"><paramref name="predicate" /> に渡す最後の整数より 1 だけ大きい数。</span><span class="sxs-lookup"><span data-stu-id="00f0f-186">One more than the last integer to pass to <paramref name="predicate" />.</span></span></param>
        <param name="predicate"><span data-ttu-id="00f0f-187">指定した範囲内の任意の整数値を評価する関数。</span><span class="sxs-lookup"><span data-stu-id="00f0f-187">The function to evaluate for any value of the integer in the specified range.</span></span></param>
        <summary><span data-ttu-id="00f0f-188">ある整数範囲内のすべての整数について指定したテストが true かどうかを判定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-188">Determines whether a specified test is true for any integer within a range of integers.</span></span></summary>
        <returns><span data-ttu-id="00f0f-189"><see langword="true" /> から <paramref name="predicate" /> - 1 の範囲の任意の整数に対して、<see langword="true" /> が <paramref name="fromInclusive" /> を返す場合は <paramref name="toExclusive" />。</span><span class="sxs-lookup"><span data-stu-id="00f0f-189"><see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for any integer starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-190">`toExclusive` パラメーターは、0から始まる整数の範囲の長さを使用しやすくするために、最後の整数より1つ大きい値です。</span><span class="sxs-lookup"><span data-stu-id="00f0f-190">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="00f0f-191">たとえば、整数 0 ~ 4 の場合は5に設定されます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-191">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="00f0f-192"><paramref name="predicate" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="00f0f-192"><paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="00f0f-193"><paramref name="toExclusive" /> は <paramref name="fromInclusive" /> より小さい値です。</span><span class="sxs-lookup"><span data-stu-id="00f0f-193"><paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Exists : seq&lt;'T&gt; * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.Exists (collection, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="00f0f-194"><paramref name="collection" /> に格納されている型。</span><span class="sxs-lookup"><span data-stu-id="00f0f-194">The type that is contained in <paramref name="collection" />.</span></span></typeparam>
        <param name="collection"><span data-ttu-id="00f0f-195"><c>に渡される型</c>T<paramref name="predicate" /> の要素が含まれているコレクション。</span><span class="sxs-lookup"><span data-stu-id="00f0f-195">The collection from which elements of type <c>T</c> will be drawn to pass to <paramref name="predicate" />.</span></span></param>
        <param name="predicate"><span data-ttu-id="00f0f-196"><paramref name="collection" /> 内の要素を評価する関数。</span><span class="sxs-lookup"><span data-stu-id="00f0f-196">The function to evaluate for an element in <paramref name="collection" />.</span></span></param>
        <summary><span data-ttu-id="00f0f-197">ある要素のコレクション内の要素が関数内に存在するかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-197">Determines whether an element within a collection of elements exists within a function.</span></span></summary>
        <returns><span data-ttu-id="00f0f-198"><see langword="true" /> 内の型 <paramref name="predicate" /> の任意の要素に対して、<see langword="true" /> が <paramref name="T" /> を返す場合にのみ <paramref name="collection" />。</span><span class="sxs-lookup"><span data-stu-id="00f0f-198"><see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for any element of type <paramref name="T" /> in <paramref name="collection" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="00f0f-199"><paramref name="collection" /> または <paramref name="predicate" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="00f0f-199"><paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll">
      <MemberSignature Language="C#" Value="public static bool ForAll (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ForAll(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member ForAll : int * int * Predicate&lt;int&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.ForAll (fromInclusive, toExclusive, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="00f0f-200"><paramref name="predicate" /> に渡す最初の整数。</span><span class="sxs-lookup"><span data-stu-id="00f0f-200">The first integer to pass to <paramref name="predicate" />.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="00f0f-201"><paramref name="predicate" /> に渡す最後の整数より 1 だけ大きい数。</span><span class="sxs-lookup"><span data-stu-id="00f0f-201">One more than the last integer to pass to <paramref name="predicate" />.</span></span></param>
        <param name="predicate"><span data-ttu-id="00f0f-202">指定された範囲の整数の存在を評価する関数。</span><span class="sxs-lookup"><span data-stu-id="00f0f-202">The function to evaluate for the existence of the integers in the specified range.</span></span></param>
        <summary><span data-ttu-id="00f0f-203">指定した範囲内のすべての整数について特定の状態が有効かどうかを判定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-203">Determines whether a particular condition is valid for all integers in a specified range.</span></span></summary>
        <returns><span data-ttu-id="00f0f-204"><see langword="true" /> から <paramref name="predicate" /> - 1 の範囲のすべての整数に対して、<see langword="true" /> が <paramref name="fromInclusive" /> を返す場合は <paramref name="toExclusive" />。</span><span class="sxs-lookup"><span data-stu-id="00f0f-204"><see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for all integers starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-205">`toExclusive` パラメーターは、0から始まる整数の範囲の長さを使用しやすくするために、最後の整数より1つ大きい値です。</span><span class="sxs-lookup"><span data-stu-id="00f0f-205">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="00f0f-206">たとえば、整数 0 ~ 4 の場合は5に設定されます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-206">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00f0f-207">次の例は、<xref:System.Diagnostics.Contracts.Contract.ForAll%2A> メソッドを使用して、配列に null 要素があるかどうかを判断する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="00f0f-207">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether an array has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="00f0f-208"><paramref name="predicate" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="00f0f-208"><paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="00f0f-209"><paramref name="toExclusive" /> は <paramref name="fromInclusive" /> より小さい値です。</span><span class="sxs-lookup"><span data-stu-id="00f0f-209"><paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span></span></exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool ForAll(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member ForAll : seq&lt;'T&gt; * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.ForAll (collection, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="00f0f-210"><paramref name="collection" /> に格納されている型。</span><span class="sxs-lookup"><span data-stu-id="00f0f-210">The type that is contained in <paramref name="collection" />.</span></span></typeparam>
        <param name="collection"><span data-ttu-id="00f0f-211"><c>に渡される型</c>T<paramref name="predicate" /> の要素が含まれているコレクション。</span><span class="sxs-lookup"><span data-stu-id="00f0f-211">The collection from which elements of type <c>T</c> will be drawn to pass to <paramref name="predicate" />.</span></span></param>
        <param name="predicate"><span data-ttu-id="00f0f-212"><paramref name="collection" /> 内のすべての要素の存在を評価する関数。</span><span class="sxs-lookup"><span data-stu-id="00f0f-212">The function to evaluate for the existence of all the elements in <paramref name="collection" />.</span></span></param>
        <summary><span data-ttu-id="00f0f-213">コレクション内のすべての要素が関数内に存在するかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-213">Determines whether all the elements in a collection exist within a function.</span></span></summary>
        <returns><span data-ttu-id="00f0f-214"><see langword="true" /> 内の型 <paramref name="predicate" /> のすべての要素に対して、<see langword="true" /> が <paramref name="T" /> を返す場合にのみ <paramref name="collection" />。</span><span class="sxs-lookup"><span data-stu-id="00f0f-214"><see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for all elements of type <paramref name="T" /> in <paramref name="collection" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="00f0f-215">次の例では、<xref:System.Diagnostics.Contracts.Contract.ForAll%2A> メソッドを使用して、コレクションに null 要素が含まれているかどうかを確認する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-215">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether a collection has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="00f0f-216"><paramref name="collection" /> または <paramref name="predicate" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="00f0f-216"><paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invariant">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="00f0f-217">外側のメソッドまたはプロパティのコントラクトを指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-217">Specifies a contract for an enclosing method or property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition);" />
      <MemberSignature Language="F#" Value="static member Invariant : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Invariant condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="00f0f-218">テストする条件式。</span><span class="sxs-lookup"><span data-stu-id="00f0f-218">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="00f0f-219">外側のメソッドまたはプロパティの不変コントラクトを指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-219">Specifies an invariant contract for the enclosing method or property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-220"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> コントラクトは、<xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> 属性によって識別されるメソッド内に含まれます。通常、メソッドには `ObjectInvariant`という名前が付けられます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-220"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="00f0f-221">このコントラクトは、クラスで宣言されている専用の不変メソッドでのみ指定できます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-221">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span> <span data-ttu-id="00f0f-222">メソッドがシールされていない場合は、サブクラスが不変性を維持できるように、プライベートメンバーではなくプロテクトメンバーだけを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-222">If the method is not sealed, it should refer only to protected members, not private members, so that subclasses can be sure to maintain the invariants.</span></span>  
  
-   <span data-ttu-id="00f0f-223">このコントラクトはクライアントに公開されません。そのため、外側のメソッドよりも見えにくくなっているメンバーを参照する場合があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-223">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="00f0f-224">このインバリアントの実行時の強制には、バイナリリライターを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-224">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="00f0f-225">インバリアントは、`CONTRACTS FULL` 記号の有無に基づいて条件付きで定義されます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-225">Invariants are conditionally defined based on the presence of the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="00f0f-226">ランタイム チェックで各パブリック メソッドの最後にチェックされます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-226">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="00f0f-227">インバリアントが同じクラスのパブリックメソッドを示している場合、通常、そのパブリックメソッドの最後に行われる不変チェックは無効になり、そのクラスに対する最も外側のメソッド呼び出しの最後にのみチェックされます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-227">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="00f0f-228">別のクラスのメソッドの呼び出しのためにクラスへの再入がなされる場合も同様です。</span><span class="sxs-lookup"><span data-stu-id="00f0f-228">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Invariant : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Invariant (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="00f0f-229">テストする条件式。</span><span class="sxs-lookup"><span data-stu-id="00f0f-229">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="00f0f-230">条件が <see langword="false" /> の場合に表示するメッセージ。</span><span class="sxs-lookup"><span data-stu-id="00f0f-230">The message to display if the condition is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="00f0f-231">外側のメソッドまたはプロパティの不変コントラクトを指定し、コントラクトの条件が失敗した場合はメッセージを表示します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-231">Specifies an invariant contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-232"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> コントラクトは、<xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> 属性によって識別されるメソッド内に含まれます。通常、メソッドには `ObjectInvariant`という名前が付けられます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-232"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="00f0f-233">このコントラクトは、クラスで宣言されている専用の不変メソッドでのみ指定できます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-233">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span>  
  
-   <span data-ttu-id="00f0f-234">このコントラクトはクライアントに公開されません。そのため、外側のメソッドよりも見えにくくなっているメンバーを参照する場合があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-234">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="00f0f-235">このインバリアントの実行時の強制には、バイナリリライターを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-235">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="00f0f-236">インバリアントは、`CONTRACTS FULL` 記号で条件付きで定義されます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-236">Invariants are conditionally defined on the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="00f0f-237">ランタイム チェックで各パブリック メソッドの最後にチェックされます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-237">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="00f0f-238">インバリアントが同じクラスのパブリックメソッドを示している場合、通常、そのパブリックメソッドの最後に行われる不変チェックは無効になり、そのクラスに対する最も外側のメソッド呼び出しの最後にのみチェックされます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-238">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="00f0f-239">別のクラスのメソッドの呼び出しのためにクラスへの再入がなされる場合も同様です。</span><span class="sxs-lookup"><span data-stu-id="00f0f-239">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OldValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T OldValue&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T OldValue&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OldValue(Of T) (value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T OldValue(T value);" />
      <MemberSignature Language="F#" Value="static member OldValue : 'T -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.OldValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="00f0f-240">値の型。</span><span class="sxs-lookup"><span data-stu-id="00f0f-240">The type of value.</span></span></typeparam>
        <param name="value"><span data-ttu-id="00f0f-241">表す値 (フィールドまたはパラメーター)。</span><span class="sxs-lookup"><span data-stu-id="00f0f-241">The value to represent (field or parameter).</span></span></param>
        <summary><span data-ttu-id="00f0f-242">メソッドまたはプロパティの開始時の値を表します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-242">Represents values as they were at the start of a method or property.</span></span></summary>
        <returns><span data-ttu-id="00f0f-243">メソッドまたはプロパティの開始時のフィールドまたはパラメーターの値。</span><span class="sxs-lookup"><span data-stu-id="00f0f-243">The value of the parameter or field at the start of a method or property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-244">このメソッドは、<xref:System.Diagnostics.Contracts.Contract.Ensures%2A> コントラクトの条件式でのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-244">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00f0f-245">次の例は、<xref:System.Diagnostics.Contracts.Contract.OldValue%2A> メソッドを使用して、カウントが更新されたことを確認する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="00f0f-245">The following example shows the use of the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method to ensure that a count has been updated.</span></span> <span data-ttu-id="00f0f-246">このコード例は、<xref:System.Diagnostics.Contracts.ContractClassAttribute> クラス用に用意されている大規模な例の一部です。</span><span class="sxs-lookup"><span data-stu-id="00f0f-246">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#5](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#5)]
 [!code-vb[ContractExample#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Requires">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="00f0f-247">外側のメソッドまたはプロパティの実行前の状態のコントラクトを指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-247">Specifies a precondition contract for an enclosing method or property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition);" />
      <MemberSignature Language="F#" Value="static member Requires : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Requires condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="00f0f-248">テストする条件式。</span><span class="sxs-lookup"><span data-stu-id="00f0f-248">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="00f0f-249">外側のメソッドまたはプロパティの実行前の状態のコントラクトを指定します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-249">Specifies a precondition contract for the enclosing method or property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="00f0f-250">このメソッドの呼び出しは、他のコードの前にあるメソッドまたはプロパティの先頭にある必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-250">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="00f0f-251">このコントラクトはクライアントに公開されます。したがって、少なくとも外側のメソッドとして表示されるメンバーのみを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-251">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="00f0f-252">旧バージョンとの互換性で特定の例外をスローする必要がない場合は、<xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> メソッドの代わりにこのメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-252">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Requires : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Requires (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="00f0f-253">テストする条件式。</span><span class="sxs-lookup"><span data-stu-id="00f0f-253">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="00f0f-254">条件が <see langword="false" /> の場合に表示するメッセージ。</span><span class="sxs-lookup"><span data-stu-id="00f0f-254">The message to display if the condition is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="00f0f-255">外側のメソッドまたはプロパティの実行前の状態のコントラクトを指定し、コントラクトの条件が失敗した場合はメッセージを表示します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-255">Specifies a precondition contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="00f0f-256">このメソッドの呼び出しは、他のコードの前にあるメソッドまたはプロパティの先頭にある必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-256">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="00f0f-257">このコントラクトはクライアントに公開されます。したがって、少なくとも外側のメソッドとして表示されるメンバーのみを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-257">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="00f0f-258">旧バージョンとの互換性で特定の例外をスローする必要がない場合は、<xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> メソッドの代わりにこのメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-258">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition);" />
      <MemberSignature Language="F#" Value="static member Requires : bool -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.Requires condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="00f0f-259">条件が <see langword="false" /> の場合にスローする例外。</span><span class="sxs-lookup"><span data-stu-id="00f0f-259">The exception to throw if the condition is <see langword="false" />.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="00f0f-260">テストする条件式。</span><span class="sxs-lookup"><span data-stu-id="00f0f-260">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="00f0f-261">外側のメソッドまたはプロパティの実行前の状態のコントラクトを指定し、コントラクトの条件が失敗した場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="00f0f-261">Specifies a precondition contract for the enclosing method or property, and throws an exception if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="00f0f-262"><xref:System.Diagnostics.Contracts.Contract.Requires%2A> メソッドを使用するには、実行時チェックをオンにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-262">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="00f0f-263">ランタイムチェックがオフになっている場合、プロセスは終了します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-263">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="00f0f-264">ランタイムチェック用のツールを取得するには、Visual Studio Marketplace の[コードコントラクト](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET)に関する記述を参照してください。</span><span class="sxs-lookup"><span data-stu-id="00f0f-264">To obtain the tools for runtime checking, see [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio Marketplace.</span></span>  
  
-   <span data-ttu-id="00f0f-265">このメソッドの呼び出しは、他のコードの前にあるメソッドまたはプロパティの先頭にある必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-265">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="00f0f-266">このコントラクトはクライアントに公開されます。したがって、少なくとも外側のメソッドとして表示されるメンバーのみを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-266">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="00f0f-267">事前条件が失敗した場合に例外をスローする場合は、<xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> メソッドの代わりにこのメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-267">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Requires : bool * string -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.Requires (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="00f0f-268">条件が <see langword="false" /> の場合にスローする例外。</span><span class="sxs-lookup"><span data-stu-id="00f0f-268">The exception to throw if the condition is <see langword="false" />.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="00f0f-269">テストする条件式。</span><span class="sxs-lookup"><span data-stu-id="00f0f-269">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="00f0f-270">条件が <see langword="false" /> の場合に表示するメッセージ。</span><span class="sxs-lookup"><span data-stu-id="00f0f-270">The message to display if the condition is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="00f0f-271">外側のメソッドまたはプロパティの実行前の状態のコントラクトを指定し、コントラクトの条件が失敗した場合は指定されたメッセージで例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="00f0f-271">Specifies a precondition contract for the enclosing method or property, and throws an exception with the provided message if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   > [!IMPORTANT]
    >  <span data-ttu-id="00f0f-272"><xref:System.Diagnostics.Contracts.Contract.Requires%2A> メソッドを使用するには、実行時チェックをオンにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-272">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="00f0f-273">ランタイムチェックがオフになっている場合、プロセスは終了します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-273">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="00f0f-274">ランタイムチェック用のツールを取得するには、Visual Studio Marketplace の[コードコントラクト](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET)に関する記述を参照してください。</span><span class="sxs-lookup"><span data-stu-id="00f0f-274">To obtain the tools for runtime checking, see [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio Marketplace.</span></span>  
  
     <span data-ttu-id="00f0f-275">このメソッドの呼び出しは、他のコードの前にあるメソッドまたはプロパティの先頭にある必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-275">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="00f0f-276">このコントラクトはクライアントに公開されます。したがって、少なくとも外側のメソッドとして表示されるメンバーのみを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="00f0f-276">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="00f0f-277">事前条件が失敗した場合に例外をスローする場合は、<xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> メソッドの代わりにこのメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-277">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Result&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Result&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Result``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Result(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Result();" />
      <MemberSignature Language="F#" Value="static member Result : unit -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.Result " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T"><span data-ttu-id="00f0f-278">外側のメソッドまたはプロパティの戻り値の型。</span><span class="sxs-lookup"><span data-stu-id="00f0f-278">Type of return value of the enclosing method or property.</span></span></typeparam>
        <summary><span data-ttu-id="00f0f-279">メソッドまたはプロパティの戻り値を表します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-279">Represents the return value of a method or property.</span></span></summary>
        <returns><span data-ttu-id="00f0f-280">外側のメソッドまたはプロパティの戻り値。</span><span class="sxs-lookup"><span data-stu-id="00f0f-280">Return value of the enclosing method or property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-281">このメソッドは、<xref:System.Diagnostics.Contracts.Contract.Ensures%2A> コントラクトの条件式でのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-281">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00f0f-282">次の例は、<xref:System.Diagnostics.Contracts.Contract.Result%2A> メソッドを使用して、予想される戻り値を指定する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="00f0f-282">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Result%2A> method to specify an expected return value.</span></span> <span data-ttu-id="00f0f-283">このコード例は、<xref:System.Diagnostics.Contracts.ContractClassAttribute> クラス用に用意されている大規模な例の一部です。</span><span class="sxs-lookup"><span data-stu-id="00f0f-283">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueAtReturn&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ValueAtReturn&lt;T&gt; (out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ValueAtReturn&lt;T&gt;([out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ValueAtReturn(Of T) (ByRef value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T ValueAtReturn([Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member ValueAtReturn : 'T -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.ValueAtReturn value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="00f0f-284"><see langword="out" /> パラメーターの型。</span><span class="sxs-lookup"><span data-stu-id="00f0f-284">The type of the <see langword="out" /> parameter.</span></span></typeparam>
        <param name="value"><span data-ttu-id="00f0f-285"><see langword="out" /> パラメーター。</span><span class="sxs-lookup"><span data-stu-id="00f0f-285">The <see langword="out" /> parameter.</span></span></param>
        <summary><span data-ttu-id="00f0f-286">メソッドから戻るときの <see langword="out" /> パラメーターの最後の (出力) 値を表します。</span><span class="sxs-lookup"><span data-stu-id="00f0f-286">Represents the final (output) value of an <see langword="out" /> parameter when returning from a method.</span></span></summary>
        <returns><span data-ttu-id="00f0f-287"><see langword="out" /> パラメーターの出力値。</span><span class="sxs-lookup"><span data-stu-id="00f0f-287">The output value of the <see langword="out" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00f0f-288">このメソッドは、<xref:System.Diagnostics.Contracts.Contract.Ensures%2A> コントラクトの条件式でのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-288">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span> <span data-ttu-id="00f0f-289"><xref:System.Diagnostics.Contracts.Contract.OldValue%2A> メソッドと同様に、コンパイラが型を推論できる場合はジェネリック型パラメーターを省略できます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-289">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="00f0f-290">このメソッドの呼び出しは、コントラクト リライターによって `out` パラメーターの値に置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="00f0f-290">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="00f0f-291"><xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> メソッドは事後条件でしか使用できません。</span><span class="sxs-lookup"><span data-stu-id="00f0f-291">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="00f0f-292">このメソッドの引数は、`out` パラメーターか、構造体の `out` パラメーターのフィールド</span><span class="sxs-lookup"><span data-stu-id="00f0f-292">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="00f0f-293">(構造体コンストラクターの事後条件でフィールドを参照する場合にも便利です) でなければなりません。</span><span class="sxs-lookup"><span data-stu-id="00f0f-293">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
