<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1a83dc1ead22c7656286e264f4a55faebb636ac0" /><Meta Name="ms.sourcegitcommit" Value="f9576bf8c61e3d46834aeeff50f858359f2a99ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="02/09/2020" /><Meta Name="ms.locfileid" Value="77104874" /></Metadata><TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Windows メッセージを処理するために、アプリケーションを開始および停止するメソッドや、アプリケーションについての情報を取得するためのプロパティなど、アプリケーションを管理するための <see langword="static" /> メソッドおよびプロパティを提供します。 このクラスは継承できません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application> クラスには、次のように、アプリケーションとスレッドを開始および停止したり、Windows メッセージを処理したりするためのメソッドがあります。  
  
-   <xref:System.Windows.Forms.Application.Run%2A> は、現在のスレッドでアプリケーションメッセージループを開始し、必要に応じてフォームを表示します。  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> または <xref:System.Windows.Forms.Application.ExitThread%2A> によってメッセージループが停止します。  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> は、プログラムがループ内にある間にメッセージを処理します。  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> は、Windows メッセージを監視するために、アプリケーションメッセージポンプにメッセージフィルターを追加します。  
  
-   <xref:System.Windows.Forms.IMessageFilter> を使用すると、イベントの発生を停止したり、イベントハンドラーを呼び出す前に特別な操作を実行したりできます。  
  
 このクラスには、現在のスレッドのカルチャ情報を取得または設定するためのプロパティと <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> <xref:System.Windows.Forms.Application.CurrentCulture%2A> があります。  
  
 このクラスのインスタンスを作成することはできません。  
  
   
  
## Examples  
 次のコード例では、フォームのリストボックス内の数値を一覧表示します。 [`button1`] をクリックするたびに、アプリケーションによってリストに別の番号が追加されます。  
  
 `Main` メソッドは、<xref:System.Windows.Forms.Application.Run%2A> を呼び出して、フォーム、`listBox1`、および `button1`を作成するアプリケーションを起動します。 ユーザーが [`button1`] をクリックすると、`button1_Click` メソッドに <xref:System.Windows.Forms.MessageBox>が表示されます。 ユーザーが <xref:System.Windows.Forms.MessageBox>の [`No`] をクリックすると、`button1_Click` メソッドによってリストに数値が追加されます。 ユーザーが [`Yes`] をクリックすると、アプリケーションは <xref:System.Windows.Forms.Application.Exit%2A> を呼び出してキュー内の残りのすべてのメッセージを処理し、終了します。  
  
> [!NOTE]
>  部分信頼では、<xref:System.Windows.Forms.Application.Exit%2A> の呼び出しが失敗します。  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">インストールする <see cref="T:System.Windows.Forms.IMessageFilter" /> インターフェイスの実装。</param>
        <summary>メッセージ フィルターを追加して、ルーティング先にルーティングされる Windows メッセージを監視します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージフィルターを使用して、特定のイベントが発生しないようにするか、イベントをイベントハンドラーに渡す前にイベントに対して特別な操作を実行します。 メッセージフィルターは、特定のスレッドに対して一意です。  
  
 メッセージがディスパッチされないようにするには、このメソッドに渡す `value` パラメーターインスタンスが、メッセージを処理するコードで <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> メソッドをオーバーライドする必要があります。 メソッドは `false`を返します。  
  
> [!CAUTION]
>  アプリケーションのメッセージポンプにメッセージフィルターを追加すると、パフォーマンスが低下する可能性があります。  
  
   
  
## Examples  
 次のコード例では、`TestMessageFilter`という名前のメッセージフィルターを作成します。 このフィルターは、マウスの左ボタンに関連するすべてのメッセージをブロックします。 メッセージフィルターを使用するには、<xref:System.Windows.Forms.IMessageFilter> インターフェイスの実装を指定する必要があります。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直前の呼び出し元がアンマネージコードを呼び出す場合は。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出し元がこのアプリケーションを終了できるかどうかを示す値を取得します。</summary>
        <value>呼び出し元がこのアプリケーションを終了できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、Web ブラウザー内でホストされている <xref:System.Windows.Forms.Control> から呼び出された場合に `false` を返します。 このため、<xref:System.Windows.Forms.Control> は <xref:System.Windows.Forms.Application>を終了できません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションをシャットダウンしようとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントハンドラーを `ApplicationExit` イベントにアタッチして、アプリケーションの実行を停止する前に、未処理の必須タスクを実行する必要があります。 このアプリケーションによって開かれたファイルを閉じることができます。また、ガベージコレクションによって再利用されなかったオブジェクトを破棄することもできます。  
  
 これは静的イベントであるため、`ApplicationExit` イベントハンドラー自体でこのイベントにアタッチされているすべてのイベントハンドラーをデタッチする必要があります。 これらのハンドラーをデタッチしないと、イベントにアタッチされたままになり、メモリが引き続き使用されます。  
  
   
  
## Examples  
 次のコード例では、2つのフォームを表示し、両方のフォームが閉じられたときにアプリケーションを終了します。 アプリケーションの開始時と終了時には、各フォームの位置が記憶されます。 この例では、`ApplicationExit` イベントを使用して、フォームの位置をファイルに保存するタイミングと、`FileStream` を閉じる必要があるタイミングを確認します。  
  
 クラス `MyApplicationContext` は <xref:System.Windows.Forms.ApplicationContext> から継承され、各フォームが閉じられた日時を追跡し、両方ともの場合、現在のスレッドを終了します。 クラスは、各フォームが閉じられたときの位置を記憶します。 `ApplicationExit` イベントが発生すると、クラスはユーザーの各の位置をファイルに書き込みます。 フォーム位置データは、<xref:System.Windows.Forms.Application.UserAppDataPath%2A>によって決定された場所に作成される `appdata.txt` という名前のファイルに格納されます。 `Main` メソッドは、`Application.Run(context)` を呼び出して、<xref:System.Windows.Forms.ApplicationContext>を指定してアプリケーションを起動します。  
  
 このコードは、<xref:System.Windows.Forms.ApplicationContext> クラスの概要に示されている例の抜粋です。 コードリスト全体については、「<xref:System.Windows.Forms.ApplicationContext>」を参照してください。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>すべてのユーザーで共有するアプリケーション データのパスを取得します。</summary>
        <value>すべてのユーザーで共有するアプリケーション データのパス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パスが存在しない場合は、次の形式で作成されます。  
  
 *ベースパス*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A>最初にメインの実行可能ファイルを含むアセンブリに `AssemblyInformationalVersion` 属性が含まれているかどうかを調べます。 この属性が存在する場合は、<xref:System.Windows.Forms.Application.ProductVersion%2A>と<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>の両方で <xref:System.Windows.Forms.Application.ProductVersion%2A>が使用されます。 この属性が存在しない場合、両方のプロパティで、実行可能ファイルのバージョンが代わりに使用されます。  
  
 パスは、Windows フォーム アプリケーションの配置に、[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]を使用しているかどうかによって異なります。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] アプリケーションは、C:\Documents and Settings\\*username* ディレクトリでユーザーごとのアプリケーション キャッシュに格納されます。 詳細については、[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications) を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>すべてのユーザーが共有するアプリケーション データのレジストリ キーを取得します。</summary>
        <value>すべてのユーザーが共有するアプリケーション データのレジストリ キーを表す <see cref="T:Microsoft.Win32.RegistryKey" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーが存在しない場合は、次の形式で作成されます。  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションに関連付けられている会社名を取得します。</summary>
        <value>会社名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、このプロパティを取得し、テキストボックスにその値を表示します。 この例では、`textBox1` がフォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドのカルチャ情報を取得または設定します。</summary>
        <value>現在のスレッドのカルチャ情報を表す <see cref="T:System.Globalization.CultureInfo" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、このプロパティを取得し、テキストボックスにその値を表示します。 この例では、`textBox1` がフォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウでこのプロパティを設定します。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドの現在の入力言語を取得または設定します。</summary>
        <value>現在のスレッドの現在の入力言語を表す <see cref="T:System.Windows.Forms.InputLanguage" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、このプロパティを取得し、テキストボックスにその値を表示します。 この例では、`textBox1` がフォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直前の呼び出し元がアンマネージコードを呼び出す場合は。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メッセージ キューに現在ある Windows メッセージをすべて処理します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows フォームを実行すると、新しいフォームが作成され、イベントが処理されるまで待機します。 フォームがイベントを処理するたびに、そのイベントに関連付けられているすべてのコードが処理されます。 他のすべてのイベントは、キューで待機します。 コードによってイベントが処理されても、アプリケーションは応答しません。 たとえば、別のウィンドウが上にドラッグされている場合、ウィンドウは再描画されません。  
  
 コードで <xref:System.Windows.Forms.Application.DoEvents%2A> を呼び出すと、アプリケーションは他のイベントを処理できます。 たとえば、<xref:System.Windows.Forms.ListBox> にデータを追加して <xref:System.Windows.Forms.Application.DoEvents%2A> をコードに追加するフォームがある場合、別のウィンドウをドラッグするとフォームが再描画されます。 コードから <xref:System.Windows.Forms.Application.DoEvents%2A> を削除すると、ボタンのクリックイベントハンドラーの実行が完了するまでフォームは再描画されません。 メッセージングの詳細については、「 [Windows フォームでのユーザー入力](~/docs/framework/winforms/user-input-in-windows-forms.md)」を参照してください。  
  
 Visual Basic 6.0 とは異なり、<xref:System.Windows.Forms.Application.DoEvents%2A> メソッドは <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> メソッドを呼び出しません。  
  
 通常、このメソッドをループで使用してメッセージを処理します。  
  
> [!CAUTION]
>  このメソッドを呼び出すと、待機中のすべてのウィンドウメッセージが処理されている間、現在のスレッドが中断されます。 メッセージによってイベントがトリガーされる場合は、アプリケーションコードの他の領域が実行される可能性があります。 これにより、アプリケーションで予期しない動作が発生し、デバッグが困難になる可能性があります。 長い時間がかかる操作や計算を実行する場合は、新しいスレッドでこれらの操作を実行することをお勧めします。 非同期プログラミングの詳細については、「[非同期プログラミングモデル (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Windows.Forms.Application.DoEvents%2A> メソッドの使用方法を示しています。 この例を実行すると、ユーザーは <xref:System.Windows.Forms.OpenFileDialog>からグラフィックスファイルを選択できます。 選択したファイルがフォームに表示されます。 <xref:System.Windows.Forms.Application.DoEvents%2A> メソッドは、開かれた各グラフィックスファイルに対してフォームを強制的に再描画します。 この例を実行するには、`PictureBox1`という名前の <xref:System.Windows.Forms.PictureBox>、`OpenFileDialog1`という名前の <xref:System.Windows.Forms.OpenFileDialog>、および `fileButton`という名前のボタンを含むフォームに次のコードを貼り付けます。 フォームのコンストラクターまたは `Load` メソッドから `InitializePictureBox` および `InitializeOpenFileDialog` メソッドを呼び出します。  
  
> [!NOTE]
>  Visual Studio では、ドラッグ操作を使用してフォームに <xref:System.Windows.Forms.OpenFileDialog> を追加する場合、<xref:System.Windows.Forms.OpenFileDialog>の新しいインスタンスを作成する行を削除することによって、次の `InitializeOpenFileDialog` メソッドを変更する必要があります。  
  
 また、この例では、<xref:System.Windows.Forms.Button> コントロールの <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> イベントと <xref:System.Windows.Forms.OpenFileDialog> の <xref:System.Windows.Forms.FileDialog.FileOk> イベントが、この例で定義されているイベントハンドラーに接続されている必要があります。 この例が実行されている場合は、ボタンをクリックしてダイアログボックスを表示します。  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションで visual スタイルを有効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アプリケーションの視覚スタイルを有効にします。 視覚スタイルとは、オペレーティングシステムのテーマを形成する色、フォント、およびその他のビジュアル要素です。 コントロールとオペレーティングシステムでサポートされている場合は、visual スタイルを使用してコントロールが描画されます。 効果を与えるには、アプリケーションでコントロールを作成する前に <xref:System.Windows.Forms.Application.EnableVisualStyles> を呼び出す必要があります。通常、<xref:System.Windows.Forms.Application.EnableVisualStyles> は `Main` 関数の最初の行です。 <xref:System.Windows.Forms.Application.EnableVisualStyles>を呼び出すときに、visual スタイルを有効にするために個別のマニフェストは必要ありません。  
  
> [!NOTE]
>  .NET Framework 2.0 より前では、コントロールを visual スタイルで描画するために、<xref:System.Windows.Forms.ButtonBase>から派生するコントロールなど、一部のコントロールの `FlatStyle` プロパティを <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> に設定する必要がありました。 .NET Framework 2.0 で記述されたアプリケーションでは、これは不要になりました。  
  
> [!NOTE]
>  このメソッドは、Internet Explorer でホストされているコントロールには影響しません。  
  
   
  
## Examples  
 次のコード例は、`Main` 関数で <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> を呼び出して、アプリケーションの visual スタイルを有効にする方法を示しています。  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがモーダル状態に入ろうとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  これは静的イベントなので、アプリケーションが破棄されるときにイベントハンドラーをデタッチする必要があります。これを行わないと、メモリリークが発生します。  
  
   
  
## Examples  
 このメンバーの使用例を次のコード例に示します。 この例では、イベントハンドラーは、<xref:System.Windows.Forms.Application.EnterThreadModal> イベントの発生を報告します。 このレポートは、イベントがいつ発生し、デバッグに役立つかを理解するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントについてレポートするには、<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> を <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> に置き換えるか、複数行 <xref:System.Windows.Forms.TextBox>にメッセージを追加することを検討してください。  
  
 コード例を実行するには、コードを Windows フォームに貼り付け、イベントハンドラーが <xref:System.Windows.Forms.Application.EnterThreadModal> イベントに関連付けられていることを確認します。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">イベントをリッスンするには、<see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> のアクセス許可が必要です。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションを開始した実行可能ファイルのパスを、ファイル名を含めて取得します。</summary>
        <value>アプリケーションを開始した実行可能ファイルのパスおよびファイル名。  
  
このパスは、Windows フォーム アプリケーションが [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] を使用して配置されているかどうかによって異なります。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] アプリケーションは、C:\Documents and Settings\\*username* ディレクトリでユーザーごとのアプリケーション キャッシュに格納されます。 詳細については、[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications) を参照してください。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスを取得するために使用します。 関連付けられた列挙型: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>終了する必要があるすべてのメッセージ ポンプを通知し、メッセージが処理されると、すべてのアプリケーション ウィンドウを閉じます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>終了する必要があるすべてのメッセージ ポンプを通知し、メッセージが処理されると、すべてのアプリケーション ウィンドウを閉じます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.Exit%2A> メソッドは、すべてのスレッドで実行中のすべてのメッセージループを停止し、アプリケーションのすべてのウィンドウを閉じます。 このメソッドは、必ずしもアプリケーションを強制的に終了するわけではありません。 <xref:System.Windows.Forms.Application.Exit%2A> メソッドは通常、メッセージループ内から呼び出され、<xref:System.Windows.Forms.Application.Run%2A> を強制的に返すようにします。 現在のスレッドに対してのみメッセージループを終了するには、<xref:System.Windows.Forms.Application.ExitThread%2A>を呼び出します。  
  
 <xref:System.Windows.Forms.Application.Exit%2A> は、次のイベントを発生させ、関連付けられた条件付きアクションを実行します。  
  
-   <xref:System.Windows.Forms.Application.OpenForms%2A> プロパティによって表されるすべてのフォームに対して、<xref:System.Windows.Forms.Form.FormClosing> イベントが発生します。 このイベントは、<xref:System.Windows.Forms.FormClosingEventArgs> パラメーターの <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> プロパティを `true`に設定することによって取り消すことができます。  
  
-   1つ以上のハンドラーがイベントをキャンセルした場合、<xref:System.Windows.Forms.Application.Exit%2A> は、それ以上のアクションを実行せずに制御を戻します。 それ以外の場合は、開いているすべてのフォームに対して <xref:System.Windows.Forms.Form.FormClosed> イベントが発生し、実行中のすべてのメッセージループとフォームが閉じられます。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Application.Exit%2A> メソッドは、[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]のために廃止された <xref:System.Windows.Forms.Form.Closed> イベントと <xref:System.Windows.Forms.Form.Closing> イベントを発生させません。  
  
   
  
## Examples  
 次のコード例では、フォームのリストボックス内の数値を一覧表示します。 [`button1`] をクリックするたびに、アプリケーションによってリストに別の番号が追加されます。  
  
 `Main` メソッドは、<xref:System.Windows.Forms.Application.Run%2A> を呼び出して、フォーム、`listBox1`、および `button1`を作成するアプリケーションを起動します。 ユーザーが [`button1`] をクリックすると、`button1_Click` メソッドによってリストボックスに 1 ~ 3 の数字が追加され、<xref:System.Windows.Forms.MessageBox>が表示されます。 ユーザーが <xref:System.Windows.Forms.MessageBox>で **[いいえ]** をクリックすると、`button1_Click` メソッドによってリストに別の番号が追加されます。 ユーザーが **[はい]** をクリックすると、アプリケーションは <xref:System.Windows.Forms.Application.Exit%2A>を呼び出して、キュー内の残りのすべてのメッセージを処理し、終了します。  
  
 この例では、`listBox1` と `button1` がインスタンス化され、フォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直前の呼び出し元がアンマネージコードを呼び出す場合は。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">アプリケーション内の <see cref="T:System.Windows.Forms.Form" /> が終了をキャンセルしたかどうかを示す値を返します。</param>
        <summary>終了する必要があるすべてのメッセージ ポンプを通知し、メッセージが処理されると、すべてのアプリケーション ウィンドウを閉じます。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">実行中のアプリケーションスレッドを終了するアクセス許可。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのメッセージ ループを終了し、スレッドのウィンドウをすべて閉じます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在のスレッドのメッセージループを終了するには、このメソッドを使用します。 このメソッドにより、現在のスレッドの <xref:System.Windows.Forms.Application.Run%2A> の呼び出しが返されます。 アプリケーション全体を終了するには、<xref:System.Windows.Forms.Application.Exit%2A>を呼び出します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直前の呼び出し元がアンマネージコードを呼び出す場合は。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage : Message -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="message">フィルター処理の対象となる Windows イベント メッセージ。</param>
        <summary>ウィンドウ メッセージに対してフィルターを実行し、変更したメッセージのコピーを返します。</summary>
        <returns>フィルターが処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HighDpiMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.HighDpiMode HighDpiMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.HighDpiMode HighDpiMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.HighDpiMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HighDpiMode As HighDpiMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::HighDpiMode HighDpiMode { System::Windows::Forms::HighDpiMode get(); };" />
      <MemberSignature Language="F#" Value="member this.HighDpiMode : System.Windows.Forms.HighDpiMode" Usage="System.Windows.Forms.Application.HighDpiMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HighDpiMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションの現在の高 DPI モードを取得します。</summary>
        <value>高 DPI モードを示す列挙値の1つ。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが処理を完了し、アイドル状態に入ろうとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドがアイドル状態になる前に実行する必要のあるタスクがある場合は、このイベントにアタッチします。  
  
> [!CAUTION]
>  これは静的イベントなので、アプリケーションが破棄されるときにイベントハンドラーをデタッチする必要があります。これを行わないと、メモリリークが発生します。  
  
   
  
## Examples  
 このメンバーの使用例を次のコード例に示します。 この例では、イベントハンドラーは、<xref:System.Windows.Forms.Application.Idle> イベントの発生を報告します。 このレポートは、イベントがいつ発生し、デバッグに役立つかを理解するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントについてレポートするには、<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> を <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> に置き換えるか、複数行 <xref:System.Windows.Forms.TextBox>にメッセージを追加することを検討してください。  
  
 コード例を実行するには、それを Windows フォームに貼り付け、イベントハンドラーが <xref:System.Windows.Forms.Application.Idle> イベントに関連付けられていることを確認します。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがモーダル状態を終了するときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  これは静的イベントなので、アプリケーションが破棄されるときにイベントハンドラーをデタッチする必要があります。これを行わないと、メモリリークが発生します。  
  
   
  
## Examples  
 このメンバーの使用例を次のコード例に示します。 この例では、イベントハンドラーは、<xref:System.Windows.Forms.Application.LeaveThreadModal> イベントの発生を報告します。 このレポートは、イベントがいつ発生し、デバッグに役立つかを理解するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントについてレポートするには、<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> を <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> に置き換えるか、複数行 <xref:System.Windows.Forms.TextBox>にメッセージを追加することを検討してください。  
  
 コード例を実行するには、コードを Windows フォームに貼り付け、イベントハンドラーが <xref:System.Windows.Forms.Application.LeaveThreadModal> イベントに関連付けられていることを確認します。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカルで非ローミング ユーザーのアプリケーション データのパスを取得します。</summary>
        <value>ローカルで非ローミング ユーザーのアプリケーション データのパス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ローカルユーザーとは、ユーザーがログオンしたシステムにユーザープロファイルが格納されているユーザーのことです。 パスが存在しない場合は、次の形式で作成されます。  
  
 *ベースパス*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 一般的な基本パスは C:\documents and と Settings\\*username*\Local Settings\Application Data です。 ただし、Windows フォームアプリケーションが [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]を使用して展開されている場合、このパスは異なります。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] は、他のすべてのアプリケーションから分離された独自のアプリケーションデータディレクトリを作成します。 詳細については、[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications) を参照してください。  
  
   
  
## Examples  
 次のコード例では、2つのフォームを表示し、両方のフォームが閉じられたときにアプリケーションを終了します。 アプリケーションの開始時と終了時には、各フォームの位置が記憶されます。 この例では、<xref:System.Windows.Forms.Application.UserAppDataPath%2A> プロパティを使用してユーザーのアプリケーションデータを格納する方法を示していますが、<xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> を代わりに使用することもできます。  
  
 `MyApplicationContext` クラスは <xref:System.Windows.Forms.ApplicationContext> から継承され、各フォームが閉じられたときに追跡を続け、両方がであるときに現在のスレッドを終了します。 クラスは、ユーザーの各フォームの位置を格納します。 フォーム位置データは、<xref:System.Windows.Forms.Application.UserAppDataPath%2A>によって決定された場所に作成される `Appdata.txt` という名前のファイルに格納されます。 `Main` メソッドは、`Application.Run(context)` を呼び出して、<xref:System.Windows.Forms.ApplicationContext>を指定してアプリケーションを起動します。  
  
 このコードは、<xref:System.Windows.Forms.ApplicationContext> クラスの概要に示されている例の抜粋です。 簡潔にするために、一部のコードは表示されません。 コードリスト全体については、「<xref:System.Windows.Forms.ApplicationContext>」を参照してください。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このスレッドにメッセージ ループが存在するかどうかを示す値を取得します。</summary>
        <value>メッセージ ループが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 管理されていないアプリケーションなど、他の環境で Windows フォームをホストする場合、このプロパティは常に `false`を返します。 <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> を使用して、ホスト環境にアクティブなメッセージループが残っているかどうか Windows フォームを指示します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドで OLE を初期化します。</summary>
        <returns><see cref="T:System.Threading.ApartmentState" /> 値のいずれか 1 つです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 OLE を必要とする `Microsoft.Win32` メソッドを呼び出す前に、このメソッドを呼び出します。 <xref:System.Windows.Forms.Application.OleRequired%2A> は、最初に、OLE が現在のスレッドで初期化されているかどうかを確認します。 そうでない場合は、OLE のスレッドを初期化します。  
  
> [!NOTE]
>  スレッドが OLE メソッドを直接呼び出す場合を除き、このメソッドを呼び出す必要はありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">スローされた例外を表す <see cref="T:System.Exception" />。</param>
        <summary><see cref="E:System.Windows.Forms.Application.ThreadException" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> を呼び出して、アプリケーションの処理を停止する例外を発生させます。  
  
 <xref:System.Windows.Forms.Application> クラスには、<xref:System.Windows.Forms.Application.ThreadException> イベントがあります。 このイベントにイベントハンドラーをアタッチして、未処理の例外に必要なカスタム処理を行うことができます。 イベントハンドラーをアタッチしない場合、<xref:System.Windows.Forms.Application.OnThreadException%2A> は既定の動作を実行します。これには、エラーが発生したことをユーザーに通知するダイアログボックスが表示されます。  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> は、Windows フォームが所有するスレッドで発生する未処理の例外に対して、既定の例外動作を実装します。 他のスレッドでのハンドルされない例外は、<xref:System.AppDomain.UnhandledException> イベントによって処理されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが所有している、開かれたフォームのコレクションを取得します。</summary>
        <value>アプリケーションによって所有されている、現在開いているすべてのフォームが格納された <see cref="T:System.Windows.Forms.FormCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.OpenForms%2A> プロパティは、アプリケーションが所有するフォームの読み取り専用コレクションを表します。 このコレクションは、インデックス位置または <xref:System.Windows.Forms.Form>の <xref:System.Windows.Forms.Control.Name%2A> で検索できます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">呼び出し元は、<see cref="T:System.Security.Permissions.UIPermissionWindow" /> 列挙の <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> 値で定義されているように、すべてのウィンドウにアクセスするためのアクセス許可を持っている必要があります。</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアプリケーションに関連付けられている製品名を取得します。</summary>
        <value>製品名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` は、現在のアプリケーションのメインフォームを含むアセンブリのメタデータから取得されます。 これは、アセンブリマニフェスト内の <xref:System.Reflection.AssemblyProductAttribute> を設定することによって設定できます。 詳細については、「[アセンブリ マニフェスト](~/docs/standard/assembly/manifest.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このプロパティを取得し、テキストボックスにその値を表示します。 この例では、`textBox1` がフォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアプリケーションに関連付けられている製品のバージョンを取得します。</summary>
        <value>製品のバージョン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、バージョン番号は*メジャー番号*として表示されます。*マイナー番号*。*ビルド番号*。*プライベートパート番号*。 アセンブリのバージョンをアセンブリマニフェスト内で設定することによって、明示的に設定できます。 詳細については、「[アセンブリ マニフェスト](~/docs/standard/assembly/manifest.md)」を参照してください。  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A>最初にメインの実行可能ファイルを含むアセンブリに `AssemblyInformationalVersion` 属性が含まれているかどうかを調べます。 この属性が存在する場合は、<xref:System.Windows.Forms.Application.ProductVersion%2A>と<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>の両方で <xref:System.Windows.Forms.Application.ProductVersion%2A>が使用されます。 この属性が存在しない場合、両方のプロパティで、実行可能ファイルのバージョンが代わりに使用されます。  
  
   
  
## Examples  
 次のコード例では、このプロパティを取得し、テキストボックスにその値を表示します。 この例では、`textBox1` がフォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> イベントに渡す <see cref="E:System.Windows.Forms.Application.Idle" /> オブジェクト。</param>
        <summary>ホストされているシナリオで <see cref="E:System.Windows.Forms.Application.Idle" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージアプリケーションなどの別の環境で Windows フォームをホストするときに使用されます。 ホストアプリケーションがアイドル状態になると、<xref:System.Windows.Forms.Application.RaiseIdle%2A> を呼び出す必要があります。 これにより、ユーザーがアプリケーションと対話していないときに、一部の Windows フォームコントロールとコンポーネントが重要なバックグラウンド作業を実行できるようになります。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">ホスト環境が依然としてメッセージを送信しているかどうかを Windows フォームでチェックする必要がある場合に呼び出すメソッド。</param>
        <summary>メッセージ ループがホストされている環境で実行されているかどうかをチェックするためのコールバックを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージアプリケーションなどの別の環境で Windows フォームをホストするときに使用されます。 ホスト環境では、Windows フォームがメッセージを処理していない場合、<xref:System.Windows.Forms.Application.MessageLoop%2A> プロパティは常に false を返します。 このコールバックを使用して、ホスト環境がまだメッセージを処理しているかどうかを Windows フォームに伝えます。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">アプリケーションから削除する <see cref="T:System.Windows.Forms.IMessageFilter" /> の実装。</param>
        <summary>アプリケーションのメッセージ ポンプからメッセージ フィルターを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows メッセージをディスパッチする前にキャプチャする必要がなくなった場合は、メッセージフィルターを削除できます。  
  
   
  
## Examples  
 メッセージフィルターを使用するには、<xref:System.Windows.Forms.IMessageFilter> インターフェイスの実装を指定する必要があります。 次のクラスは、`TestMessageFilter`という名前のメッセージフィルターを作成します。 このフィルターは、マウスの左ボタンに関連するすべてのメッセージをブロックします。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアプリケーションが visual スタイルを使用してコントロールを描画しているかどうかを示す値を取得します。</summary>
        <value>アプリケーション ウィンドウのクライアント領域のコントロールで visual スタイルが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタムコントロールを描画する場合は、このプロパティを使用して、コントロールの外観がアプリケーション内の他のコントロールと一致するように、visual スタイルを使用するかどうかを決定します。  
  
 次の表は、<xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> が `true`を返すために必要な4つの条件を示しています。  
  
|条件|説明|  
|---------------|-----------------|  
|オペレーティングシステムは、視覚スタイルをサポートしています|この条件を個別に確認するには、 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> クラスの <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> プロパティを使用します。|  
|ユーザーがオペレーティングシステムで視覚スタイルを有効にしている|この条件を個別に確認するには、 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> クラスの <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> プロパティを使用します。|  
|アプリケーションで Visual スタイルが有効になっている|アプリケーションで視覚スタイルを有効にするには、 <xref:System.Windows.Forms.Application.EnableVisualStyles> メソッドを呼び出すか、ComCtl32.dll バージョン 6 以降をコントロールの描画に使用することを指定するアプリケーション マニフェストを使用します。|  
|アプリケーションウィンドウのクライアント領域を描画するために Visual スタイルが使用されています|この条件を個別に確認するには、 <xref:System.Windows.Forms.Application.VisualStyleState%2A> クラスの <xref:System.Windows.Forms.Application> プロパティを使用し、その値が <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> または <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>になっていることを確認します。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションをシャットダウンし、直後に新しいインスタンスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Restart` を呼び出す最も一般的な理由は、`Update` または `UpdateAsync` メソッドを使用して [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] ダウンロードしたアプリケーションの新しいバージョンを起動することです。  
  
 アプリケーションは、最初に実行されたコンテキストで再起動されます。 アプリケーションのメインの実行可能ファイルを直接指す URL を使用してアプリケーションが起動された場合は、同じ URL を使用して再起動されます。 アプリケーションが [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] アプリケーションである場合は、[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]を使用してアプリケーションが再起動されます。  
  
 アプリケーションが最初に実行されたときにコマンドラインオプションを指定した場合、<xref:System.Windows.Forms.Application.Restart%2A> は同じオプションを使用してアプリケーションを再び起動します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows フォーム アプリケーションのコードではありません。 このコンテキストではこのメソッドを呼び出すことはできません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> 権限が必要です。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のスレッドで標準のアプリケーション メッセージ ループの実行を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドで標準のアプリケーション メッセージ ループの実行を、フォームなしで開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Win32 ベースまたは Windows フォームアプリケーションでは、メッセージループは、マウスのクリックやキーボードのストロークなどのユーザーイベントを処理するコード内のルーチンです。 Windows ベースのすべてのアプリケーションを実行するには、メインメッセージループと呼ばれるアクティブなメッセージループが必要です。 メインメッセージループが終了すると、アプリケーションは終了します。 Windows フォームでは、このループは、<xref:System.Windows.Forms.Application.Exit%2A> メソッドが呼び出されたとき、またはメインメッセージループを実行しているスレッドで <xref:System.Windows.Forms.Application.ExitThread%2A> メソッドが呼び出されたときに閉じられます。  
  
 ほとんどの Windows フォーム開発者は、このバージョンのメソッドを使用する必要はありません。 メインフォームが閉じられたときにアプリケーションが終了するように、<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> オーバーロードを使用して、メインフォームでアプリケーションを起動する必要があります。 それ以外の場合は、<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> のオーバーロードを使用します。これにより、アプリケーションの有効期間の制御を強化するために <xref:System.Windows.Forms.ApplicationContext> オブジェクトを指定できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メイン メッセージ ループが既にこのスレッドで実行中です。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">アプリケーションが実行される <see cref="T:System.Windows.Forms.ApplicationContext" />。</param>
        <summary><see cref="T:System.Windows.Forms.ApplicationContext" /> を使用して、現在のスレッドで標準のアプリケーション メッセージ ループの実行を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージループは、<xref:System.Windows.Forms.Application.Exit%2A> または <xref:System.Windows.Forms.Application.ExitThread%2A> が呼び出されるか、コンテキストオブジェクトで <xref:System.Windows.Forms.Application.ThreadExit> イベントが発生するまで実行されます。  
  
   
  
## Examples  
 この例では、2つのフォームを表示し、両方のフォームが閉じられたときにアプリケーションを終了します。 アプリケーションの開始時と終了時には、各フォームの位置が記憶されます。 この例では、<xref:System.Windows.Forms.ApplicationContext>を `Application.Run(context)` メソッドと共に使用して、アプリケーションの起動時に複数のフォームを表示する方法を示します。  
  
 クラス `MyApplicationContext` は <xref:System.Windows.Forms.ApplicationContext> から継承され、各フォームが閉じられたことを追跡し、両方がである場合は現在のスレッドを終了します。 クラスは、ユーザーの各フォームの位置を格納します。 フォーム位置データは、<xref:System.Windows.Forms.Application.UserAppDataPath%2A>によって決定された場所に作成される `Appdata.txt` という名前のファイルに格納されます。 `Main` メソッドは、`Application.Run(context)` を呼び出して、<xref:System.Windows.Forms.ApplicationContext>を指定してアプリケーションを起動します。  
  
 簡潔にするために、`AppForm1` フォームと `AppForm2` フォームのコードは示されていません。 コードリスト全体については、<xref:System.Windows.Forms.ApplicationContext> クラスの概要を参照してください。  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メイン メッセージ ループが既にこのスレッドで実行中です。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">表示するフォームを表す <see cref="T:System.Windows.Forms.Form" />。</param>
        <summary>現在のスレッドで標準のアプリケーション メッセージ ループの実行を開始し、指定したフォームを表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、アプリケーションの main 関数は、このメソッドを呼び出し、アプリケーションのメインウィンドウに渡します。  
  
 このメソッドは、<xref:System.Windows.Forms.Form.Closed> イベントの `mainForm` パラメーターにイベントハンドラーを追加します。 イベントハンドラーは、アプリケーションをクリーンアップするために <xref:System.Windows.Forms.Application.ExitThread%2A> を呼び出します。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Form> クラスの <xref:System.Windows.Forms.Control.Dispose%2A> メソッドは、このメソッドが返される前に呼び出されます。  
  
   
  
## Examples  
 次のコード例では、フォームのリストボックス内の数値を一覧表示します。 [`button1`] をクリックするたびに、アプリケーションによってリストに別の番号が追加されます。  
  
 `Main` メソッドは、<xref:System.Windows.Forms.Application.Run%2A> を呼び出して、フォーム、`listBox1`、および `button1`を作成するアプリケーションを起動します。 ユーザーが [`button1`] をクリックすると、`button1_Click` メソッドによってリストボックスに 1 ~ 3 の数字が追加され、<xref:System.Windows.Forms.MessageBox>が表示されます。 ユーザーが <xref:System.Windows.Forms.MessageBox>で **[いいえ]** をクリックすると、`button1_Click` メソッドによってリストに別の番号が追加されます。 ユーザーが **[はい]** をクリックすると、アプリケーションは <xref:System.Windows.Forms.Application.Exit%2A> を呼び出してキュー内の残りのすべてのメッセージを処理し、終了します。  
  
 この例では、`listBox1` と `button1` が作成され、フォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メイン メッセージ ループが既に現在のスレッドで実行中です。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>警告見出しと共に表示された場合にトップレベル ウィンドウのキャプションに適用する書式指定文字列を取得または設定します。</summary>
        <value>トップレベル ウィンドウのキャプションに適用する書式指定文字列。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">すべてのウィンドウでこのプロパティを設定します。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="defaultValue">新しいコントロールに適用する既定値。 <see langword="true" /> の場合、<c>UseCompatibleTextRendering</c> をサポートする新しいコントロールは、テキスト レンダリングに [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] ベースの <see cref="T:System.Drawing.Graphics" /> クラスを使用します。<see langword="false" /> の場合、新しいコントロールは [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] ベースの <see cref="T:System.Windows.Forms.TextRenderer" /> クラスを使用します。</param>
        <summary>特定のコントロールで定義された <c>UseCompatibleTextRendering</c> プロパティにアプリケーション全体で有効な既定値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定の Windows フォームコントロールでは、[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] グラフィックスライブラリに基づく <xref:System.Windows.Forms.TextRenderer> クラス、または [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] グラフィックスライブラリに基づく <xref:System.Drawing.Graphics> クラスを使用して、テキストを表示できます。 この変更は、[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]のパフォーマンスとローカリゼーションの問題のために [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] に加えられました。 <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> を使用して、それをサポートするコントロールの `UseCompatibleTextRendering` プロパティの既定値を設定します。  
  
 `UseCompatibleTextRendering` プロパティは、<xref:System.Windows.Forms.TextRenderer> クラスを使用してテキストを表示する Windows フォームコントロールと、[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] クラスを使用してカスタムテキストレンダリングを実行する [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] および <xref:System.Drawing.Graphics> アプリケーションの間で、視覚的な互換性を提供するためのものです。 ほとんどの場合、アプリケーションが [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] または [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]からアップグレードされていない場合は、`UseCompatibleTextRendering` を既定値の `false`に設定したままにしておくことをお勧めします。  
  
 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] ベースの <xref:System.Windows.Forms.TextRenderer> クラスは [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] で導入され、パフォーマンスの向上、テキストの見栄え向上、および国際対応フォントのサポートの向上を実現しました。 以前のバージョンの [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]では、[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] ベースの <xref:System.Drawing.Graphics> クラスを使用してすべてのテキスト表示を実行していました。 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] は、文字間隔と単語の折り返しを [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]とは異なる方法で計算します。 <xref:System.Drawing.Graphics> クラスを使用してテキストを表示する Windows フォームアプリケーションでは、<xref:System.Windows.Forms.TextRenderer> を使用するコントロールのテキストが、アプリケーション内の他のテキストとは異なるように表示される可能性があります。 この非互換性を解決するには、`UseCompatibleTextRendering` プロパティを `true`に設定します。 アプリケーションでサポートされているすべてのコントロールの `UseCompatibleTextRendering` を `true` に設定するには、`true`のパラメーターを指定して <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> メソッドを呼び出します。  
  
 Windows フォームコードが Internet Explorer などの別のアプリケーションでホストされている場合は、このメソッドを呼び出さないでください。 スタンドアロンの Windows フォームアプリケーションでのみ、このメソッドを呼び出します。  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] 以降の `UseCompatibleTextRendering` の既定値を設定するには、「<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>」を参照してください。  
  
 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 以降では、<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> の呼び出しが Program.cs ファイルに自動的に生成されます。 テキスト表示の既定値を変更するには、生成されたコードを変更します。  
  
```csharp  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">このメソッドは、Windows フォーム アプリケーションによって最初のウィンドウが作成される前にしか呼び出すことができません。</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetHighDpiMode">
      <MemberSignature Language="C#" Value="public static bool SetHighDpiMode (System.Windows.Forms.HighDpiMode highDpiMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetHighDpiMode(valuetype System.Windows.Forms.HighDpiMode highDpiMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetHighDpiMode(System.Windows.Forms.HighDpiMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetHighDpiMode(System::Windows::Forms::HighDpiMode highDpiMode);" />
      <MemberSignature Language="F#" Value="static member SetHighDpiMode : System.Windows.Forms.HighDpiMode -&gt; bool" Usage="System.Windows.Forms.Application.SetHighDpiMode highDpiMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highDpiMode" Type="System.Windows.Forms.HighDpiMode" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="highDpiMode">設定する高 DPI モードを指定する列挙値の 1 つ。</param>
        <summary>プロセスの高 DPI モードを設定します。</summary>
        <returns>高 DPI モードが設定されている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

アプリケーションにアプリケーションマニフェストファイルが存在し、そのファイルで DPI モードが設定されている場合、このメソッドは、アプリケーションマニフェストによって既に設定されているモードを設定または変更できません。 高 DPI モードは、プロセスごとに1回設定されます。 アプリケーションマニフェストファイルを使用した DPI モードの設定の詳細については、「[プロセスに対する既定の dpi 認識の設定](https://docs.microsoft.com/previous-versions/windows/desktop/legacy/mt846517(v%3Dvs.85))」を参照してください。

  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="force" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="state">移行後の電源の動作モードを示す <see cref="T:System.Windows.Forms.PowerState" />。</param>
        <param name="force">すぐに、強制的に中断モードにする場合は <see langword="true" />。Windows からすべてのアプリケーションに中断の要求が送られるようにする場合は <see langword="false" />。</param>
        <param name="disableWakeEvent">システムの電源ステータスの復元が wake イベントでアクティブにならないようにするには <see langword="true" />。システムの電源ステータスの復元が wake イベントでアクティブになるようにするには <see langword="false" />。</param>
        <summary>システムを中断または休止状態にするか、システムが中断または休止状態になるよう要求します。</summary>
        <returns>システムが中断中の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションが20秒以内に中断要求に応答しない場合、Windows は応答しない状態であると判断し、アプリケーションをスリープ状態または終了時に配置できます。 ただし、アプリケーションが中断要求に応答すると、リソースをクリーンアップし、アクティブなプロセスをシャットダウンするために必要な時間がかかることがあります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>未処理の例外への対応方法をアプリケーションに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、Windows フォームのスレッドで発生する例外と、他のスレッドで発生する例外のイベントハンドラーを設定します。 アプリケーションのユーザー構成ファイルの設定に関係なく、すべての例外がアプリケーションによって処理されるように <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> を設定します。 UI スレッドの例外を処理するために <xref:System.Windows.Forms.Application.ThreadException> イベントを使用し、UI 以外のスレッドの例外を処理するための <xref:System.AppDomain.UnhandledException> イベントを使用します。 <xref:System.AppDomain.UnhandledException> によってアプリケーションが終了するのを防ぐことができないため、この例では、終了する前にアプリケーションイベントログにエラーを記録するだけです。  
  
 この例では、<xref:System.Windows.Forms.Form> クラスに2つの <xref:System.Windows.Forms.Button> コントロール `button1` と `button2`が定義されていることを前提としています。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">キャッチされない例外がスローされた場合に必要なアプリケーションの動作方法を説明する <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 値。</param>
        <summary>未処理の例外への対応方法をアプリケーションに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多くの場合、Windows フォームによってスローされたすべての例外をキャッチすることはできません。 このメソッドを使用して、Windows フォームコンポーネントによってスローされた未処理の例外をすべてキャッチし、操作を続行するかどうか、またはユーザーに公開して実行を中止するかどうかをアプリケーションに指示できます。  
  
 <xref:System.Windows.Forms.Application.Run%2A> メソッドを使用してアプリケーションのメインフォームをインスタンス化する前に、<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> を呼び出します。  
  
 Windows フォームによって作成および所有されていないスレッドで発生した例外をキャッチするには、<xref:System.AppDomain.UnhandledException> イベントハンドラーを使用します。  
  
   
  
## Examples  
 次のコード例では、Windows フォームのスレッドで発生する例外と、他のスレッドで発生する例外のイベントハンドラーを設定します。 アプリケーションのユーザー構成ファイルの設定に関係なく、すべての例外がアプリケーションによって処理されるように <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> を設定します。 UI スレッドの例外を処理するために <xref:System.Windows.Forms.Application.ThreadException> イベントを使用し、UI 以外のスレッドの例外を処理するための <xref:System.AppDomain.UnhandledException> イベントを使用します。 <xref:System.AppDomain.UnhandledException> によってアプリケーションが終了するのを防ぐことができないため、この例では、終了する前にアプリケーションイベントログにエラーを記録するだけです。  
  
 この例では、<xref:System.Windows.Forms.Form> クラスに2つの <xref:System.Windows.Forms.Button> コントロール `button1` と `button2`が定義されていることを前提としています。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">アプリケーションが最初のウィンドウを作成した後に、例外モードを設定することはできません。</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="threadScope" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">キャッチされない例外がスローされた場合に必要なアプリケーションの動作方法を説明する <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 値。</param>
        <param name="threadScope">スレッド例外モードを設定する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>未処理の例外に応答する方法をアプリケーションに指示し、オプションでスレッド固有の動作を適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多くの場合、Windows フォームによってスローされたすべての例外をキャッチすることはできません。 このメソッドを使用して、Windows フォームコンポーネントによってスローされた未処理の例外をすべてキャッチし、操作を続行するかどうか、またはユーザーに公開して実行を中止するかどうかをアプリケーションに指示できます。  
  
 <xref:System.Windows.Forms.Application.Run%2A> メソッドを使用してアプリケーションのメインフォームをインスタンス化する前に、<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> を呼び出します。  
  
 `threadScope` が `true`場合、スレッド例外モードが設定されます。 `mode` が <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>に設定されていない場合、スレッド例外モードはアプリケーション例外モードをオーバーライドします。  
  
 `threadScope` が `false`場合、アプリケーションの例外モードが設定されます。 アプリケーション例外モードは、<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> モードのすべてのスレッドで使用されます。 アプリケーション例外モードを設定しても、現在のスレッドの設定には影響しません。  
  
 Windows フォームによって作成および所有されていないスレッドで発生した例外をキャッチするには、<xref:System.AppDomain.UnhandledException> イベントハンドラーを使用します。  
  
   
  
## Examples  
 次のコード例では、Windows フォームのスレッドで発生する例外と、他のスレッドで発生する例外のイベントハンドラーを設定します。 アプリケーションのユーザー構成ファイルの設定に関係なく、すべての例外がアプリケーションによって処理されるように <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> を設定します。 UI スレッドの例外を処理するために <xref:System.Windows.Forms.Application.ThreadException> イベントを使用し、UI 以外のスレッドの例外を処理するための <xref:System.AppDomain.UnhandledException> イベントを使用します。 <xref:System.AppDomain.UnhandledException> によってアプリケーションが終了するのを防ぐことができないため、この例では、終了する前にアプリケーションイベントログにエラーを記録するだけです。  
  
 この例では、<xref:System.Windows.Forms.Form> クラスに2つの <xref:System.Windows.Forms.Button> コントロール `button1` と `button2`が定義されていることを前提としています。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">アプリケーションが最初のウィンドウを作成した後に、例外モードを設定することはできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションを開始した実行可能ファイルの、ファイル名を含まないパスを取得します。</summary>
        <value>アプリケーションを開始した実行可能ファイルのパス。  
  
このパスは、Windows フォーム アプリケーションが [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] を使用して配置されているかどうかによって異なります。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] アプリケーションは、C:\Documents and Settings\\*username* ディレクトリでユーザーごとのアプリケーション キャッシュに格納されます。 詳細については、[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications) を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、このプロパティを取得し、テキストボックスにその値を表示します。 この例では、`textBox1` がフォームに配置されている必要があります。  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスを取得するために使用します。 関連付けられた列挙型: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>トラップされないスレッドの例外がスローされると、発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントを使用すると、Windows フォームアプリケーションは、Windows フォームスレッドで発生する未処理の例外を処理できます。 イベントハンドラーを <xref:System.Windows.Forms.Application.ThreadException> イベントにアタッチして、これらの例外を処理します。これにより、アプリケーションは不明な状態のままになります。 可能であれば、構造化例外処理ブロックで例外を処理する必要があります。  
  
 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>を設定することによって、未処理の Windows フォームスレッド例外にこのコールバックを使用するかどうかを変更できます。 Windows フォームによって作成および所有されていないスレッドで発生した例外をキャッチするには、<xref:System.AppDomain.UnhandledException> イベントハンドラーを使用します。  
  
> [!NOTE]
>  このイベントのアクティブ化が欠落していないことを保証するには、<xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>を呼び出す前にハンドラーをアタッチする必要があります。  
  
> [!NOTE]
>  このイベントにアタッチできるハンドラーは1つだけです。 複数のハンドラーを追加した場合、未処理の例外に対して、最後に追加されたハンドラーのみが呼び出されます。
  
> [!CAUTION]
>  これは静的イベントなので、アプリケーションが破棄されるときにイベントハンドラーをデタッチする必要があります。これを行わないと、メモリリークが発生します。  
  
   
  
## Examples  
 次のコード例では、Windows フォームのスレッドで発生する例外と、他のスレッドで発生する例外のイベントハンドラーを設定します。 アプリケーションのユーザー構成ファイルの設定に関係なく、すべての例外がアプリケーションによって処理されるように <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> を設定します。 UI スレッドの例外を処理するために <xref:System.Windows.Forms.Application.ThreadException> イベントを使用し、UI 以外のスレッドの例外を処理するための <xref:System.AppDomain.UnhandledException> イベントを使用します。 <xref:System.AppDomain.UnhandledException> によってアプリケーションが終了するのを防ぐことができないため、この例では、終了する前にアプリケーションイベントログにエラーを記録するだけです。  
  
 この例では、<xref:System.Windows.Forms.Form> クラスに2つの <xref:System.Windows.Forms.Button> コントロール `button1` と `button2`が定義されていることを前提としています。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">このイベントにハンドラーを追加するときに、直前の呼び出し元がアンマネージコードを呼び出す場合は。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドをシャットダウンしようとすると発生します。 アプリケーションのメイン スレッドをシャットダウンしようとすると、まずこのイベントが発生し、続いて <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> イベントが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントハンドラーを <xref:System.Windows.Forms.Application.ThreadExit> イベントにアタッチして、スレッドの実行を停止する前に未処理の必須タスクを実行する必要があります。 このスレッドによって開かれたファイルを閉じるか、ガベージコレクターによって再利用されなかったオブジェクトを破棄します。  
  
> [!CAUTION]
>  これは静的イベントなので、アプリケーションが破棄されるときにイベントハンドラーをデタッチする必要があります。これを行わないと、メモリリークが発生します。  
  
   
  
## Examples  
 このメンバーの使用例を次のコード例に示します。 この例では、イベントハンドラーは、<xref:System.Windows.Forms.Application.ThreadExit> イベントの発生を報告します。 このレポートは、イベントがいつ発生し、デバッグに役立つかを理解するのに役立ちます。 複数のイベントまたは頻繁に発生するイベントについてレポートするには、<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> を <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> に置き換えるか、複数行 <xref:System.Windows.Forms.TextBox>にメッセージを追加することを検討してください。  
  
 コード例を実行するには、コードを Windows フォームに貼り付け、イベントハンドラーが <xref:System.Windows.Forms.Application.ThreadExit> イベントに関連付けられていることを確認します。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" /> によってなされたメッセージ ループ コールバックを登録解除します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーのアプリケーション データのパスを取得します。</summary>
        <value>ユーザーのアプリケーション データのパス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パスが存在しない場合は、次の形式で作成されます。  
  
 *ベースパス*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 このパスに格納されるデータは、ローミングが有効になっているユーザープロファイルの一部です。 ローミングユーザーは、ネットワーク内の複数のコンピューターで動作します。 ローミングユーザーのユーザープロファイルはネットワーク上のサーバーに保存され、ユーザーがログオンするとシステムに読み込まれます。 ユーザープロファイルがローミング対象と見なされるようにするには、オペレーティングシステムがローミングプロファイルをサポートしている必要があり、有効になっている必要があります。  
  
 一般的な基本パスは C:\documents and と Settings\\*username*\Application Data です。 ただし、Windows フォームアプリケーションが [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]を使用して展開されている場合、このパスは異なります。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] は、他のすべてのアプリケーションから分離された独自のアプリケーションデータディレクトリを作成します。 詳細については、[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](/visualstudio/deployment/accessing-local-and-remote-data-in-clickonce-applications) を参照してください。  
  
   
  
## Examples  
 次のコード例では、2つのフォームを表示し、両方のフォームが閉じられたときにアプリケーションを終了します。 アプリケーションの開始時と終了時には、各フォームの位置が記憶されます。 この例では、<xref:System.Windows.Forms.Application.UserAppDataPath%2A> プロパティを使用して、ユーザーのアプリケーションデータを格納する方法を示します。  
  
 クラス `MyApplicationContext` は <xref:System.Windows.Forms.ApplicationContext> から継承され、各フォームが閉じられたことを追跡し、両方がである場合は現在のスレッドを終了します。 クラスは、ユーザーの各フォームの位置を格納します。 フォーム位置データは、<xref:System.Windows.Forms.Application.UserAppDataPath%2A>によって決定された場所に作成される `Appdata.txt` という名前のファイルに格納されます。 `Main` メソッドは、`Application.Run(context)` を呼び出して、<xref:System.Windows.Forms.ApplicationContext>を指定してアプリケーションを起動します。  
  
 このコードは、<xref:System.Windows.Forms.ApplicationContext> クラスの概要に示されている例の抜粋です。 簡潔にするために、一部のコードは表示されません。 コードリスト全体については、「<xref:System.Windows.Forms.ApplicationContext>」を参照してください。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーのアプリケーション データのレジストリ キーを取得します。</summary>
        <value>ユーザー固有のアプリケーション データのレジストリ キーを表す <see cref="T:Microsoft.Win32.RegistryKey" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーが存在しない場合は、次の形式で作成されます。  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 このキーに格納されているデータは、ローミングが有効になっているユーザープロファイルの一部です。 ローミングユーザーは、ネットワーク内の複数のコンピューターで動作します。 ローミングユーザーのユーザープロファイルはネットワーク上のサーバーに保存され、ユーザーがログオンするとシステムに読み込まれます。 ユーザープロファイルがローミング対象と見なされるようにするには、オペレーティングシステムがローミングプロファイルをサポートしている必要があり、有効になっている必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseVisualStyles">
      <MemberSignature Language="C#" Value="public static bool UseVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UseVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UseVisualStyles : bool" Usage="System.Windows.Forms.Application.UseVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>視覚スタイルがアプリケーションに対して有効になっているかどうかを示す値を取得します。</summary>
        <value>visual スタイルが有効になっている場合に <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.Windows.Forms.Application.EnableVisualStyles>を呼び出すことによって、視覚スタイルを有効にすることができます。

OS でサポートされていない場合、またはテーマが OS レベルで無効になっている場合、visual スタイルは有効になりません。

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションの開いているフォームすべてに待機カーソルを使用するかどうかについて、取得または設定します。</summary>
        <value>すべての開いているフォームで待機カーソルが使用される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを `true`に設定すると、アプリケーションで開いているすべてのフォームの <xref:System.Windows.Forms.Control.UseWaitCursor%2A> プロパティが `true`に設定されます。 この呼び出しは、このプロパティがすべてのフォームに設定されるまでは戻りません。 このプロパティは、実行時間の長い操作があり、その操作がまだ処理中であることをすべてのアプリケーションフォームで示す場合に使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ウィンドウに visual スタイルをどのように適用するかを指定する値を取得します。</summary>
        <value><see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> 値のビットごとの組み合わせ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この <xref:System.Windows.Forms.Application.VisualStyleState%2A> プロパティは、アプリケーションウィンドウのクライアント領域または非クライアント領域で visual スタイルを有効にするかどうかを決定します。 通常、このプロパティは、メインフォームのコンストラクターまたは <xref:System.Windows.Forms.Form.Load> イベントハンドラー内で設定する必要があります。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Application.VisualStyleState%2A> プロパティを、<xref:System.Windows.Forms.Button> コントロールの <xref:System.Windows.Forms.Control.Click> イベントハンドラー内のいずれかの <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> 値に設定します。 このコード例は、<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> 列挙型に対して提供される大規模な例の一部です。  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
